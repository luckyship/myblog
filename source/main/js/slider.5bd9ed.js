(()=>{var __webpack_modules__={"./source-src/js/Q.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar module = {\n  exports: {}\n};\nvar exports = module.exports;\n(function () {\n  /*!\r\n   * Q.js v1.0.12\r\n   * Inspired from vue.js\r\n   * (c) 2016 Daniel Yang\r\n   * Released under the MIT License.\r\n   */\n\n  /**\r\n   * Just support modern browser\r\n   */\n\n  (function webpackUniversalModuleDefinition(root, factory) {\n    if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && __webpack_require__.amdO) define([], factory);else if (typeof exports === 'object') exports[\"Q\"] = factory();else root[\"Q\"] = factory();\n  })(this, function () {\n    return (/******/function (modules) {\n        // webpackBootstrap\n        /******/ // The module cache\n        /******/\n        var installedModules = {};\n\n        /******/ // The require function\n        /******/\n        function __nested_webpack_require_820__(moduleId) {\n          /******/ // Check if module is in cache\n          /******/if (installedModules[moduleId]) /******/return installedModules[moduleId].exports;\n\n          /******/ // Create a new module (and put it into the cache)\n          /******/\n          var module = installedModules[moduleId] = {\n            /******/exports: {},\n            /******/id: moduleId,\n            /******/loaded: false\n            /******/\n          };\n\n          /******/ // Execute the module function\n          /******/\n          modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_820__);\n\n          /******/ // Flag the module as loaded\n          /******/\n          module.loaded = true;\n\n          /******/ // Return the exports of the module\n          /******/\n          return module.exports;\n          /******/\n        }\n\n        /******/ // expose the modules object (__webpack_modules__)\n        /******/\n        __nested_webpack_require_820__.m = modules;\n\n        /******/ // expose the module cache\n        /******/\n        __nested_webpack_require_820__.c = installedModules;\n\n        /******/ // __webpack_public_path__\n        /******/\n        __nested_webpack_require_820__.p = \"\";\n\n        /******/ // Load entry module and return exports\n        /******/\n        return __nested_webpack_require_820__(0);\n        /******/\n      }\n      /************************************************************************/\n      /******/([/* 0 */\n      /***/function (module, exports, __nested_webpack_require_2312__) {\n        var utils = __nested_webpack_require_2312__(1),\n          _ = __nested_webpack_require_2312__(3),\n          factory = __nested_webpack_require_2312__(4);\n        _.extend(utils, _);\n        module.exports = factory(utils);\n\n        /***/\n      }, /* 1 */\n      /***/function (module, exports, __nested_webpack_require_2600__) {\n        var noop = function () {},\n          defer = window.requestAnimationFrame || window.webkitRequestAnimationFrame || setTimeout,\n          cache = new (__nested_webpack_require_2600__(2))(1000),\n          // priority directives\n          priorities = ['vm', 'repeat', 'if'],\n          _qtid = 0,\n          _slice = [].slice,\n          _alpaca = document.getElementsByTagName('html')[0],\n          slice = function () {\n            try {\n              _slice.call(document.body.childNodes);\n              return _slice;\n            } catch (e) {\n              return function (i) {\n                i = i || 0;\n                var res = [],\n                  l = this.length;\n                for (; i < l; i++) {\n                  res.push(this[i]);\n                }\n                return res;\n              };\n            }\n          }();\n        _alpaca && (_alpaca = _alpaca.getAttribute('alpaca'));\n        function _loopPriority(el, res, setting) {\n          var attr, tmp;\n\n          // TODO need optimization\n          for (var j = 0, l = priorities.length; j < l; j++) {\n            attr = 'q-' + priorities[j];\n            if (tmp = el.getAttribute(attr)) {\n              res.push({\n                name: attr,\n                value: tmp\n              });\n              el.removeAttribute(attr);\n              // has priority directive\n              return true;\n            }\n          }\n        }\n        function walk($el, cb, setting) {\n          setting = setting || {};\n          var i, j, l, el, atts, res, qtid;\n          for (i = 0; el = $el[i++];) {\n            if (el.nodeType === 1) {\n              atts = el.attributes;\n              res = [];\n\n              // loop the priority directive\n              if (!_loopPriority(el, res, setting)) {\n                // loop other directive\n                for (j = 0, l = atts.length; j < l; j++) {\n                  atts[j].name.indexOf('q-') === 0 && res.push({\n                    name: atts[j].name,\n                    value: atts[j].value\n                  });\n                }\n              }\n              res.length > 0 && cb(el, res, setting);\n            }\n            if (el.childNodes.length && !setting.stop) walk(slice.call(el.childNodes, 0), cb, setting);\n            // reset stop\n            setting.stop = false;\n          }\n        }\n        module.exports = {\n          slice: slice,\n          noop: noop,\n          /**\r\n           * Add class with compatibility for IE & SVG\r\n           *\r\n           * @param {Element} el\r\n           * @param {Strong} cls\r\n           */\n          addClass: function (el, cls) {\n            if (el.classList) {\n              el.classList.add(cls);\n            } else {\n              var cur = ' ' + (el.className || '') + ' ';\n              if (cur.indexOf(' ' + cls + ' ') < 0) {\n                el.className = (cur + cls).trim();\n              }\n            }\n          },\n          /**\r\n           * Remove class with compatibility for IE & SVG\r\n           *\r\n           * @param {Element} el\r\n           * @param {Strong} cls\r\n           */\n          removeClass: function (el, cls) {\n            if (el.classList) {\n              el.classList.remove(cls);\n            } else {\n              var cur = ' ' + (el.className || '') + ' ',\n                tar = ' ' + cls + ' ';\n              while (cur.indexOf(tar) >= 0) {\n                cur = cur.replace(tar, ' ');\n              }\n              el.className = cur.trim();\n            }\n          },\n          noexist: function (vm, name) {\n            this.warn(vm);\n            throw new Error('Filter ' + name + ' hasn\\'t implemented.');\n          },\n          warn: function () {\n            return window.console && console.error ? function () {\n              console.error.apply(console, arguments);\n            } : noop;\n          }(),\n          isObject: function (o) {\n            return typeof o === 'object';\n          },\n          nextTick: function (cb, ctx) {\n            return ctx ? defer(function () {\n              cb.call(ctx);\n            }, 0) : defer(cb, 0);\n          },\n          /**\r\n           * get\r\n           * @param {String} namespace\r\n           * @param {String} key\r\n           * @returns {String}\r\n           */\n          get: function (namespace, key) {\n            var arr = [];\n            namespace && arr.push(namespace);\n            key && arr.push(key);\n            return arr.join('.').replace(/^(.+\\.)?\\$top\\./, '');\n          },\n          walk: walk,\n          /**\r\n           * alpaca\r\n           * just a flag\r\n           */\n          alpaca: !!_alpaca\n        };\n\n        /***/\n      }, /* 2 */\n      /***/function (module, exports) {\n        /**\r\n         * just a copy of: https://github.com/yyx990803/vue/blob/master/src/cache.js\r\n         *\r\n         * @param {Number} limit\r\n         * @constructor\r\n         */\n\n        function Cache(limit) {\n          this.size = 0;\n          this.limit = limit;\n          this.head = this.tail = undefined;\n          this._keymap = {};\n        }\n        var p = Cache.prototype;\n\n        /**\r\n         * Put <value> into the cache associated with <key>.\r\n         * Returns the entry which was removed to make room for\r\n         * the new entry. Otherwise undefined is returned.\r\n         * (i.e. if there was enough room already).\r\n         *\r\n         * @param {String} key\r\n         * @param {*} value\r\n         * @return {Entry|undefined}\r\n         */\n\n        p.put = function (key, value) {\n          var entry = {\n            key: key,\n            value: value\n          };\n          this._keymap[key] = entry;\n          if (this.tail) {\n            this.tail.newer = entry;\n            entry.older = this.tail;\n          } else {\n            this.head = entry;\n          }\n          this.tail = entry;\n          if (this.size === this.limit) {\n            return this.shift();\n          } else {\n            this.size++;\n          }\n        };\n\n        /**\r\n         * Purge the least recently used (oldest) entry from the\r\n         * cache. Returns the removed entry or undefined if the\r\n         * cache was empty.\r\n         */\n\n        p.shift = function () {\n          var entry = this.head;\n          if (entry) {\n            this.head = this.head.newer;\n            this.head.older = undefined;\n            entry.newer = entry.older = undefined;\n            this._keymap[entry.key] = undefined;\n          }\n          return entry;\n        };\n\n        /**\r\n         * Get and register recent use of <key>. Returns the value\r\n         * associated with <key> or undefined if not in cache.\r\n         *\r\n         * @param {String} key\r\n         * @param {Boolean} returnEntry\r\n         * @return {Entry|*}\r\n         */\n\n        p.get = function (key, returnEntry) {\n          var entry = this._keymap[key];\n          if (entry === undefined) return;\n          if (entry === this.tail) {\n            return returnEntry ? entry : entry.value;\n          }\n          // HEAD--------------TAIL\n          //   <.older   .newer>\n          //  <--- add direction --\n          //   A  B  C  <D>  E\n          if (entry.newer) {\n            if (entry === this.head) {\n              this.head = entry.newer;\n            }\n            entry.newer.older = entry.older; // C <-- E.\n          }\n\n          if (entry.older) {\n            entry.older.newer = entry.newer; // C. --\x3e E\n          }\n\n          entry.newer = undefined; // D --x\n          entry.older = this.tail; // D. --\x3e E\n          if (this.tail) {\n            this.tail.newer = entry; // E. <-- D\n          }\n\n          this.tail = entry;\n          return returnEntry ? entry : entry.value;\n        };\n        module.exports = Cache;\n\n        /***/\n      }, /* 3 */\n      /***/function (module, exports) {\n        var DELEGATOR_CALLBACKS_KEY = '__cbs__',\n          NO_DELEGATOR = {\n            // prevent mouseover trigger more than one time\n            mouseover: true,\n            change: true,\n            input: true,\n            porpertychange: true\n          };\n        var _extend = function (target, srcs) {\n            srcs = [].splice.call(arguments, 1);\n            var i = 0,\n              l = srcs.length,\n              src,\n              key;\n            for (; i < l; i++) {\n              src = srcs[i];\n              for (key in src) {\n                target[key] = src[key];\n              }\n            }\n            return target;\n          },\n          _expando = 'QDataUid',\n          _uid = 0,\n          _map = {};\n        function contains(a, b) {\n          return a !== b && a.contains(b);\n        }\n        function data(el, key, value) {\n          var uid = el[_expando] = el[_expando] || ++_uid,\n            data = _map[uid] = _map[uid] || {};\n          // set Data\n          if (value === undefined) return data[key];\n          return data[key] = value;\n        }\n        function add(el, evt, fn) {\n          evt.split(' ').forEach(function (e) {\n            el.addEventListener(e, fn, false);\n          });\n        }\n        module.exports = {\n          find: function (selector) {\n            return this.slice.call(document.querySelectorAll(selector), 0);\n          },\n          contains: contains,\n          data: data,\n          cleanData: function (els) {\n            var uid;\n            els.forEach(function (el) {\n              var uid = el[_expando];\n              // has data\n              uid && uid in _map && delete _map[uid];\n            });\n          },\n          add: function (el, evt, fn, vm) {\n            if (!vm || NO_DELEGATOR[evt]) {\n              add(el, evt, fn);\n            } else {\n              var $el = vm.$el,\n                cbs = data($el, DELEGATOR_CALLBACKS_KEY);\n              if (!cbs) {\n                cbs = [];\n                data($el, DELEGATOR_CALLBACKS_KEY, cbs);\n                add($el, evt, function (e) {\n                  var target = e.target;\n                  cbs.forEach(function (cb) {\n                    var fn = cb.fn,\n                      el = cb.el;\n                    if (contains(el, target)) {\n                      fn.call(el, e);\n                    }\n                  });\n                });\n              }\n              // push\n              cbs.push({\n                el: el,\n                fn: fn\n              });\n            }\n          },\n          remove: function (el, evt, fn) {\n            el.removeEventListener(evt, fn, false);\n          },\n          clone: function (ele) {\n            return ele.cloneNode(true);\n          },\n          extend: function (target) {\n            if (arguments.length === 1) return _extend(this, target);\n            return _extend.apply(this, arguments);\n          }\n        };\n\n        /***/\n      }, /* 4 */\n      /***/function (module, exports, __nested_webpack_require_13336__) {\n        module.exports = function (_) {\n          var Seed = __nested_webpack_require_13336__(5),\n            events = __nested_webpack_require_13336__(6),\n            MARK = /\\{\\{(.+?)\\}\\}/,\n            mergeOptions = __nested_webpack_require_13336__(7).mergeOptions,\n            clas = __nested_webpack_require_13336__(8),\n            _doc = document;\n          function _inDoc(ele) {\n            return _.contains(_doc.documentElement, ele);\n          }\n\n          // lifecycle: created -> compiled\n\n          /**\r\n           * Q\r\n           * @class\r\n           * @param {Object} options\r\n           */\n          function Q(options) {\n            this._init(options);\n          }\n          // exports utils\n          Q._ = _;\n          Q.options = {\n            directives: __nested_webpack_require_13336__(9),\n            filters: {}\n          };\n          /**\r\n           * get\r\n           * @param {String | Element} selector\r\n           * @return {Q}\r\n           */\n          Q.get = function (selector) {\n            var ele = _.find(selector)[0];\n            if (ele) {\n              return _.data(ele, 'QI');\n            } else {\n              return new this({\n                el: selector\n              });\n            }\n          };\n          /**\r\n           * all\r\n           * @param {Object} options\r\n           */\n          Q.all = function (options) {\n            var self = this;\n            return _.find(options.el).map(function (ele) {\n              return new self(_.extend(options, {\n                el: ele\n              }));\n            });\n          };\n          _.extend(Q, clas);\n          _.extend(Q.prototype, {\n            _init: function (options) {\n              options = options || {};\n              this.$el = options.el && typeof options.el === 'string' ? _.find(options.el)[0] : options.el;\n              // element references\n              this.$$ = {};\n              // set parent vm\n              this.$parent = options._parent;\n              // merge options\n              options = this.$options = mergeOptions(this.constructor.options, options, this);\n              // lifecycle state\n              this._isCompiled = false;\n              this._isAttached = false;\n              this._isReady = false;\n              // events bookkeeping\n              this._events = {};\n              this._watchers = {};\n\n              // components\n              this._children = [];\n              // components references\n              this.$ = {};\n              Seed.call(this, options);\n              // this._data = options.data;\n              // initialize data and scope inheritance.\n              this._initScope();\n              // call created hook\n              this._callHook('created');\n              // start compilation\n              if (this.$el) {\n                // cache the instance\n                _.data(this.$el, 'QI', this);\n                this.$mount(this.$el);\n              }\n            },\n            /**\r\n             * Listen on the given `event` with `fn`.\r\n             *\r\n             * @param {String} event\r\n             * @param {Function} fn\r\n             */\n            $on: function (event, fn) {\n              (this._events[event] || (this._events[event] = [])).push(fn);\n              return this;\n            },\n            /**\r\n             * Adds an `event` listener that will be invoked a single\r\n             * time then automatically removed.\r\n             *\r\n             * @param {String} event\r\n             * @param {Function} fn\r\n             */\n            $once: function (event, fn) {\n              var self = this;\n              function on() {\n                self.$off(event, on);\n                fn.apply(this, arguments);\n              }\n              on.fn = fn;\n              this.$on(event, on);\n              return this;\n            },\n            /**\r\n             * Remove the given callback for `event` or all\r\n             * registered callbacks.\r\n             *\r\n             * @param {String} event\r\n             * @param {Function} fn\r\n             */\n\n            $off: function (event, fn) {\n              var cbs, cb, i;\n              // all event\n              if (!arguments.length) {\n                this._events = {};\n                return this;\n              }\n              // specific event\n              cbs = this._events[event];\n              if (!cbs) {\n                return this;\n              }\n              if (arguments.length === 1) {\n                this._events[event] = null;\n                return this;\n              }\n              // specific handler\n              i = cbs.length;\n              while (i--) {\n                cb = cbs[i];\n                if (cb === fn || cb.fn === fn) {\n                  cbs.splice(i, 1);\n                  break;\n                }\n              }\n              return this;\n            },\n            /**\r\n             * Watch an expression, trigger callback when its\r\n             * value changes.\r\n             *\r\n             * @param {String} exp\r\n             * @param {Function} cb\r\n             * @param {Boolean} [deep]\r\n             * @param {Boolean} [immediate]\r\n             * @return {Function} - unwatchFn\r\n             */\n            $watch: function (exp, cb, deep, immediate) {\n              var key = deep ? exp + '**deep**' : exp;\n              (this._watchers[key] || (this._watchers[key] = [])).push(cb);\n              immediate && cb(this.data(exp));\n              return this;\n            },\n            /**\r\n             * Trigger an event on self.\r\n             *\r\n             * @param {String} e\r\n             */\n            $emit: function (e) {\n              var args = _.slice.call(arguments, 1);\n              events.emit.call(this, e, _.slice.call(args, 0));\n              // emit data change\n              if (!e.indexOf('data:')) {\n                e = e.substring(5);\n                events.callChange.call(this, e, _.slice.call(args, 0));\n              }\n              if (!e.indexOf('deep:')) {\n                e = e.substring(5);\n                events.callDeep.call(this, e, _.slice.call(args, 0));\n                args.unshift(e);\n                events.emit.call(this, 'datachange', args);\n              }\n              return this;\n            },\n            /**\r\n             * Setup the scope of an instance, which contains:\r\n             * - observed data\r\n             * - computed properties\r\n             * - user methods\r\n             * - meta properties\r\n             */\n            _initScope: function () {\n              this._initMethods();\n            },\n            /**\r\n             * Setup instance methods. Methods must be bound to the\r\n             * instance since they might be called by children\r\n             * inheriting them.\r\n             */\n            _initMethods: function () {\n              var methods = this.$options.methods,\n                key;\n              if (methods) {\n                for (key in methods) {\n                  this[key] = methods[key].bind(this);\n                }\n              }\n            },\n            /**\r\n             * Set instance target element and kick off the compilation\r\n             * process. The passed in `el` can be a template string, an\r\n             * existing Element, or a DocumentFragment (for block\r\n             * instances).\r\n             *\r\n             * @param {String|Element|DocumentFragment} el\r\n             * @public\r\n             */\n            $mount: function (el) {\n              if (this._isCompiled) {\n                return _.warn('$mount() should be called only once');\n              }\n              // TODO for template || we may not do for template\n              // if (typeof el === 'string') {\n              //\n              // }\n              this._compile(el);\n              this._isCompiled = true;\n              this._callHook('compiled');\n              if (_inDoc(this.$el)) {\n                this._callHook('attached');\n                this._ready();\n              } else {\n                this.$once('hook:attached', this._ready);\n              }\n            },\n            /**\r\n             * ready\r\n             */\n            _ready: function () {\n              this._isAttached = true;\n              this._isReady = true;\n              this._callHook('ready');\n            },\n            /**\r\n             * Transclude, compile and link element.\r\n             *\r\n             * If a pre-compiled linker is available, that means the\r\n             * passed in element will be pre-transcluded and compiled\r\n             * as well - all we need to do is to call the linker.\r\n             *\r\n             * Otherwise we need to call transclude/compile/link here.\r\n             *\r\n             * @param {Element} el\r\n             * @return {Element}\r\n             */\n            _compile: function (el) {\n              this.transclue(el, this.$options);\n            },\n            /**\r\n             * Process an element or a DocumentFragment based on a\r\n             * instance option object. This allows us to transclude\r\n             * a template node/fragment before the instance is created,\r\n             * so the processed fragment can then be cloned and reused\r\n             * in v-repeat.\r\n             *\r\n             * @param {Element} el\r\n             * @param {Object} options\r\n             */\n            transclue: function (el, options) {\n              // just bind template\n              this._templateBind(el, options);\n            },\n            /**\r\n             * bind rendered template\r\n             */\n            _templateBind: __nested_webpack_require_13336__(11),\n            /**\r\n             * Trigger all handlers for a hook\r\n             *\r\n             * @param {String} hook\r\n             */\n            _callHook: function (hook) {\n              var handlers = this.$options[hook];\n              if (handlers) {\n                for (var i = 0, j = handlers.length; i < j; i++) {\n                  handlers[i].call(this);\n                }\n              }\n              this.$emit('hook:' + hook);\n            },\n            _makeReadFilters: function (names, $this) {\n              if (!names.length) return [];\n              var filters = this.$options.filters,\n                self = this;\n              return names.map(function (args) {\n                args = _.slice.call(args, 0);\n                var name = args.shift();\n                var reader = filters[name] ? filters[name].read || filters[name] : _.noexist(self, name);\n                return function (value, oldVal) {\n                  // don't modify args\n                  var thisArgs = [value].concat(args || []),\n                    i = thisArgs.indexOf('$this');\n                  thisArgs.push(oldVal);\n                  // replace $this\n                  if (~i) {\n                    thisArgs[i] = $this;\n                  }\n                  return args ? reader.apply(self, thisArgs) : reader.call(self, value, oldVal);\n                };\n              });\n            },\n            /**\r\n             * Apply filters to a value\r\n             *\r\n             * @param {*} value\r\n             * @param {Array} filters\r\n             * @param {*} oldVal\r\n             * @return {*}\r\n             */\n            applyFilters: function (value, filters, oldVal) {\n              if (!filters || !filters.length) {\n                return value;\n              }\n              for (var i = 0, l = filters.length; i < l; i++) {\n                value = filters[i].call(this, value, oldVal);\n              }\n              return value;\n            }\n          });\n          _.extend(Q.prototype, Seed.prototype);\n          return Q;\n        };\n\n        /***/\n      }, /* 5 */\n      /***/function (module, exports, __nested_webpack_require_25008__) {\n        var _ = __nested_webpack_require_25008__(1);\n\n        /**\r\n         * prefix data\r\n         * @param {Data || DataArray} up\r\n         * @param {String} key\r\n         * @param {*} value\r\n         * @param {Boolean} trigger or not\r\n         */\n        function _prefix(up, key, value, trigger) {\n          var top = up._top,\n            isArray = _isArray(value),\n            options = {\n              data: value,\n              up: up,\n              top: top,\n              namespace: key + '',\n              trigger: isArray ? false : trigger\n            },\n            // old value\n            oldVal = top.data ? top.data(up.$namespace(key)) : undefined;\n          if (typeof value === 'object' && value !== null) {\n            up[key] = isArray ? new DataArray(options) : new Data(options);\n\n            // trigger data change\n            trigger && up.$change(up.$namespace(key), up[key], oldVal);\n          } else if (oldVal !== value) {\n            up[key] = value;\n            // trigger data change\n            trigger && up.$change(up.$namespace(key), value, oldVal);\n          }\n          if (!~up._keys.indexOf(key)) up._keys.push(key);\n        }\n        function _isArray(obj) {\n          return Array.isArray(obj) || obj instanceof DataArray;\n        }\n        function _getLength(keys) {\n          return keys.filter(function (key) {\n            return typeof key === 'number';\n          }).length;\n        }\n\n        /**\r\n         * Data\r\n         * @class\r\n         * @param {Object} options\r\n         */\n        function Data(options) {\n          var data = options.data,\n            keys = Object.keys(options.data || {}).filter(function (key) {\n              return key.indexOf('_') !== 0;\n            }).map(function (num) {\n              return +num + '' === num ? +num : num;\n            }),\n            self = this;\n          _.extend(this, data);\n\n          // all key need to traverse\n          this._keys = keys;\n          // parent data container\n          this._up = options.up;\n          // the most top parent data container\n          this._top = options.top || this;\n          // the namespace of data\n          this._namespace = options.namespace || '';\n          keys.forEach(function (key) {\n            _prefix(self, key, data[key], options.trigger);\n          });\n          // if it is a array\n          _isArray(data) && (\n          // fix the length\n          this.length = _getLength(keys));\n        }\n        _.extend(Data.prototype, {\n          /**\r\n           * get the namespace\r\n           */\n          $namespace: function (key) {\n            var keys = [],\n              self = this;\n            for (; self != undefined; self = self._up) {\n              self._namespace && keys.unshift(self._namespace);\n            }\n            if (key) keys.push(key);\n            return keys.join('.');\n          },\n          /**\r\n           * get the key of it's parent\r\n           */\n          $key: function () {\n            var key = this._namespace;\n            return +key + '' === key ? +key : key;\n          },\n          /**\r\n           * get the parent of the data\r\n           */\n          $up: function (num) {\n            num = num || 1;\n            for (var src = this; num--;) {\n              src = src['_up'];\n            }\n            return src;\n          },\n          /**\r\n           * set the value of the key\r\n           */\n          $set: function (key, value) {\n            if (typeof key === 'object') {\n              var self = this;\n              Object.keys(key).filter(function (k) {\n                return k.indexOf('_') !== 0;\n              }).forEach(function (k) {\n                _prefix(self, k, key[k], true);\n              });\n              this.$change(this.$namespace(key), this, undefined, 1);\n            } else {\n              var oldValue = this[key];\n              _prefix(this, key, value, true);\n              // just bubble\n              this.$change(this.$namespace(key), this[key], oldValue, undefined, -1);\n            }\n            return this;\n          },\n          /**\r\n           * get the actual value\r\n           */\n          $get: function () {\n            var res,\n              keys = this._keys,\n              self = this;\n            if (this instanceof Data) {\n              res = {};\n            } else {\n              res = [];\n            }\n            keys.forEach(function (key) {\n              res[key] = self[key] == null ? self[key] : self[key].$get ? self[key].$get() : self[key];\n            });\n            return res;\n          },\n          /**\r\n           * change\r\n           * type = 0 just change\r\n           * type = 1 trigger change & deep\r\n           * type = -1 just deep\r\n           */\n          $change: function (key, value, oldVal, patch, type) {\n            type = type || 0;\n            var top = this._top;\n            if (top.$emit) {\n              ~type && this._top.$emit('data:' + key, value, oldVal, patch);\n              type && this._top.$emit('deep:' + key, value, oldVal, patch);\n            }\n          }\n        });\n\n        /**\r\n         * DataArray\r\n         * Something just like Array\r\n         * @class\r\n         * @param {Object} options\r\n         */\n        function DataArray(options) {\n          Data.call(this, options);\n        }\n        _.extend(DataArray.prototype, Data.prototype, {\n          /**\r\n           * push data\r\n           */\n          push: function (values) {\n            values = _.slice.call(arguments, 0);\n            var res = [];\n            for (var i = 0, l = values.length; i < l; i++) {\n              _prefix(this, this.length, values[i]);\n              this._keys.push(this.length);\n              res.push(this[this.length]);\n              this.length++;\n            }\n            // value, oldValue, patch\n            this.$change(this.$namespace(), this, null, {\n              method: 'push',\n              res: res,\n              args: values\n            }, 1);\n            return this;\n          },\n          /**\r\n           * pop data\r\n           */\n          pop: function () {\n            var res = this[--this.length];\n            delete this[this.length];\n            this._keys.pop();\n            this.$change(this.$namespace(), this, null, undefined, 1);\n            return res;\n          },\n          /**\r\n           * unshift\r\n           */\n          unshift: function (value) {\n            this._keys.push(this.length);\n            this.length++;\n            for (var l = this.length; l--;) {\n              this[l] = this[l - 1];\n              // fixed namespace\n              typeof this[l] === 'object' && (this[l]._namespace = l + '');\n            }\n            _prefix(this, 0, value);\n            this.$change(this.$namespace(), this, null, undefined, 1);\n            return this;\n          },\n          /**\r\n           * shift\r\n           */\n          shift: function () {\n            this.length--;\n            var res = this[0];\n            for (var i = 0, l = this.length; i < l; i++) {\n              this[i] = this[i + 1];\n              // fixed namespace\n              typeof this[i] === 'object' && (this[i]._namespace = i + '');\n            }\n            this._keys.pop();\n            delete this[this.length];\n            this.$change(this.$namespace(), this, null, undefined, 1);\n            return res;\n          },\n          /**\r\n           * touch\r\n           */\n          touch: function (key) {\n            this.$change(this.$namespace(key), this, null, undefined, 1);\n          },\n          /**\r\n           * indexOf\r\n           */\n          indexOf: function (item) {\n            if (item._up === this) {\n              var i = +item._namespace;\n              if (this[i] === item) return i;\n            } else if (typeof item !== 'object') {\n              for (var i = 0, l = this.length; i < l; i++) {\n                if (this[i] === item) return i;\n              }\n            }\n            return -1;\n          },\n          /**\r\n           * splice\r\n           */\n          splice: function (i, l /**, items support later **/) {\n            var patch = {\n              method: 'splice',\n              args: [i, l]\n            };\n            for (var j = 0, k = l + i, z = this.length - l; i < z; i++, j++) {\n              this[i] = this[k + j];\n              typeof this[i] === 'object' && (this[i]._namespace = i + '');\n            }\n            for (; i < this.length; i++) {\n              this[i] = null;\n              delete this[i];\n            }\n            this.length -= l;\n            this._keys.splice(this.length, l);\n            this.$change(this.$namespace(), this, null, patch, 1);\n          },\n          /**\r\n           * forEach\r\n           */\n          forEach: function (foo) {\n            for (var i = 0, l = this.length; i < l; i++) {\n              foo(this[i], i);\n            }\n          },\n          /**\r\n           * filter\r\n           */\n          filter: function (foo) {\n            var res = [];\n            this.forEach(function (item, i) {\n              if (foo(item)) res.push(item);\n            });\n            return res;\n          }\n        });\n\n        /**\r\n         * Seed\r\n         * @param {Object} options\r\n         */\n        function Seed(options) {\n          Data.call(this, options);\n        }\n        _.extend(Seed, {\n          Data: Data,\n          DataArray: DataArray\n        });\n        _.extend(Seed.prototype, Data.prototype, {\n          /**\r\n           * Set data and Element value\r\n           *\r\n           * @param {String} key\r\n           * @param {*} value\r\n           * @returns {Data}\r\n           */\n          data: function (key, value) {\n            if (key === undefined) return this;\n            var i = 0,\n              l,\n              data = this,\n              next;\n            if (~key.indexOf('.')) {\n              var keys = key.split('.');\n              for (l = keys.length; i < l - 1; i++) {\n                key = keys[i];\n                // key is number\n                if (+key + '' === key) key = +key;\n                if (key in data && data[key] != null) {\n                  data = data[key];\n                } else if (value === undefined) {\n                  // data is undefind\n                  return undefined;\n                } else {\n                  next = keys[i + 1];\n                  // next is number\n                  if (+next + '' == next) {\n                    // set a array\n                    _prefix(data, key, [], true);\n                  } else {\n                    // set a object\n                    _prefix(data, key, {}, true);\n                  }\n                }\n              }\n            }\n            l && (key = keys[i]);\n            // if data === undefined, just return\n            if (value === undefined) return data && key ? data[key] : data;\n            data.$set(key, value);\n            return data[key];\n          }\n        });\n        module.exports = Seed;\n\n        /***/\n      }, /* 6 */\n      /***/function (module, exports, __nested_webpack_require_35987__) {\n        var Data = __nested_webpack_require_35987__(5),\n          _ = __nested_webpack_require_35987__(1);\n        function emit(key, args, target) {\n          // set the trigger target is pass in or this\n          target = target || this;\n          var cbs = this._events[key];\n          if (cbs) {\n            var i = 0;\n            cbs = cbs.length > 1 ? _.slice.call(cbs, 0) : cbs;\n            for (var l = cbs.length; i < l; i++) {\n              cbs[i].apply(target, args);\n            }\n          }\n          // emit parent\n          // prevent data: event and hook: event trigger\n          if (key.indexOf('data:') && key.indexOf('hook:') && key.indexOf('deep:') && this.$parent) {\n            emit.call(this.$parent, key, args, target);\n          }\n        }\n        function callChange(key, args) {\n          var self = {\n            _events: this._watchers\n          };\n          emit.call(self, key, args);\n          emit.call(self, key + '**deep**', args);\n        }\n        function callDeep(key, args) {\n          var props,\n            nArgs,\n            keys = key.split('.'),\n            self = {\n              _events: this._watchers\n            };\n          for (keys.pop(); keys.length > 0; keys.pop()) {\n            key = keys.join('.');\n            props = key + '**deep**';\n            // remove the old value\n            emit.call(self, props, [this.data(key)]);\n          }\n          // emit vm is change\n          emit.call(self, '**deep**', [this]);\n        }\n        module.exports = {\n          emit: emit,\n          callChange: callChange,\n          callDeep: callDeep\n        };\n\n        /***/\n      }, /* 7 */\n      /***/function (module, exports, __nested_webpack_require_37664__) {\n        var _ = __nested_webpack_require_37664__(1);\n        var strats = {};\n        strats.created = strats.ready = strats.attached = strats.detached = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.paramAttributes = function (parentVal, childVal) {\n          return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n        };\n        strats.data = strats.filters = strats.methods = strats.directives = function (parentVal, childVal) {\n          if (!childVal) return parentVal;\n          if (!parentVal) return childVal;\n          return _.extend({}, parentVal, childVal);\n        };\n        var defaultStrat = function (parentVal, childVal) {\n          return childVal === undefined ? parentVal : childVal;\n        };\n\n        /**\r\n         * Option overwriting strategies are functions that handle\r\n         * how to merge a parent option value and a child option\r\n         * value into the final value.\r\n         *\r\n         * All strategy functions follow the same signature:\r\n         *\r\n         * @param {*} parentVal\r\n         * @param {*} childVal\r\n         * @param {Vue} [vm]\r\n         */\n        function mergeOptions(parent, child, vm) {\n          var options = {},\n            key;\n          for (key in parent) {\n            merge(key);\n          }\n          for (key in child) {\n            if (!parent.hasOwnProperty(key)) {\n              merge(key);\n            }\n          }\n          function merge(key) {\n            var strat = strats[key] || defaultStrat;\n            options[key] = strat(parent[key], child[key], vm, key);\n          }\n          return options;\n        }\n        module.exports = {\n          strats: strats,\n          mergeOptions: mergeOptions\n        };\n\n        /***/\n      }, /* 8 */\n      /***/function (module, exports, __nested_webpack_require_39527__) {\n        // Modules map\n        var modules = {},\n          mergeOptions = __nested_webpack_require_39527__(7).mergeOptions,\n          listeners = {};\n        function _define(name, options) {\n          if (modules[name]) return false;\n          var module = modules[name] = this.extend(options || {});\n          return module;\n        }\n        function _require(name, callback) {\n          return modules[name] || this;\n        }\n        function _create(o) {\n          function F() {}\n          F.prototype = o;\n          return new F();\n        }\n        function _extend(extendOptions) {\n          extendOptions = extendOptions || {};\n          var Super = this,\n            Sub = createClass(extendOptions.name || 'QComponent');\n          Sub.prototype = _create(Super.prototype);\n          Sub.prototype.constructor = Sub;\n          Sub.options = mergeOptions(Super.options, extendOptions);\n          Sub['super'] = Super;\n          ['extend', 'get', 'all', 'require', 'define'].forEach(function (key) {\n            Sub[key] = Super[key];\n          });\n          return Sub;\n        }\n        function createClass(name) {\n          return new Function('return function ' + name + ' (options) { this._init(options) }')();\n        }\n        module.exports = {\n          /**\r\n           * define\r\n           * define a component\r\n           * @param {String} name\r\n           * @param {Object} options\r\n           */\n          define: _define,\n          /**\r\n           * require\r\n           * require(name)\r\n           * require(names, callback)\r\n           * require a component\r\n           * @param {String} name\r\n           * @param {Array} names\r\n           * @param {Function} callback\r\n           */\n          require: _require,\n          /**\r\n           * extend\r\n           * extend the class\r\n           * @param {Object} options\r\n           */\n          extend: _extend\n        };\n\n        /***/\n      }, /* 9 */\n      /***/function (module, exports, __nested_webpack_require_41502__) {\n        var _ = __nested_webpack_require_41502__(1),\n          strats = __nested_webpack_require_41502__(7);\n        var PROP_REG = /^(.*)\\.([\\w\\-]+)$/;\n        module.exports = {\n          cloak: {\n            bind: function () {\n              var vm = this.vm,\n                el = this.el;\n\n              // after ready\n              vm.$once('hook:ready', function () {\n                // if data change\n                vm.$once('datachange', function () {\n                  el.removeAttribute('q-cloak');\n                });\n              });\n            }\n          },\n          show: function (value) {\n            var el = this.el;\n            if (value) {\n              el.style.display = '';\n              var display = el.currentStyle ? el.currentStyle.display : getComputedStyle(el, null).display;\n              if (display === 'none') {\n                el.style.display = 'block';\n              }\n            } else {\n              el.style.display = 'none';\n            }\n          },\n          'class': function (value) {\n            var el = this.el,\n              arg = this.arg;\n            if (arg) {\n              value ? _.addClass(el, arg) : _.removeClass(el, arg);\n            } else {\n              if (this.lastVal) {\n                _.removeClass(el, this.lastVal);\n              }\n              if (value) {\n                _.addClass(el, value);\n                this.lastVal = value;\n              }\n            }\n          },\n          value: function (value) {\n            var el = this.el;\n            if (el.type === 'checkbox') {\n              el.checked = value;\n            } else {\n              el.value = value;\n            }\n          },\n          attr: function (value) {\n            if (value === undefined) return;\n            var arg = this.arg,\n              el = this.el;\n            // property\n            if (arg === 'style') {\n              if (typeof value === 'object') {\n                for (var k in value) {\n                  if (value.hasOwnProperty(k)) {\n                    el.style[k] = value[k];\n                  }\n                }\n              } else {\n                el.setAttribute(arg, value);\n              }\n            } else {\n              if (arg in el) {\n                el[arg] = value;\n              } else {\n                el.setAttribute(arg, value);\n              }\n            }\n          },\n          text: function (value) {\n            var text;\n            value !== undefined && (text = typeof this.el.textContent === 'string' ? 'textContent' : 'innerText') && (this.el[text] = value == null ? '' : value.toString());\n          },\n          html: function (value) {\n            this.el.innerHTML = value && value.toString() || '';\n          },\n          on: {\n            bind: function () {\n              var self = this,\n                key = this.target,\n                param = this.param,\n                filters = this.filters,\n                vm = this.vm,\n                handler = vm.applyFilters(this.vm[key], filters),\n                data = param && ~param.indexOf('this') && self.data();\n              _.add(this.el, this.arg, function (e) {\n                if (!handler || typeof handler !== 'function') {\n                  return _.warn('You need implement the ' + key + ' method.');\n                }\n                var args = [];\n                param ? param.forEach(function (arg) {\n                  if (arg === 'e') args.push(e);else if (arg === 'this') args.push(data);else if (arg === 'true') args.push(true);else if (arg === 'false') args.push(false);else if (+arg + '' === arg) args.push(+arg);else if (arg.match(/^(['\"]).*\\1$/)) args.push(arg.slice(1, -1));else args.push(self.data(arg));\n                }) : args.push(e);\n                handler.apply(vm, args);\n              });\n            }\n          },\n          model: {\n            bind: function () {\n              var keys = ((this.namespace ? this.namespace + '.' : '') + this.target).split('.'),\n                key = keys.pop(),\n                namespace = keys.join('.'),\n                el = this.el,\n                vm = this.vm,\n                data = vm.data(namespace),\n                composing = false;\n              _.add(el, 'input propertychange change keypress keyup', function (e) {\n                if (composing) return;\n                data.$set(key, el.value);\n              });\n              _.add(el, 'compositionstart', function (e) {\n                composing = true;\n              });\n              _.add(el, 'compositionend', function (e) {\n                composing = false;\n              });\n            },\n            update: function (value) {\n              if (this.el.value !== value) {\n                this.el.value = value;\n              }\n            }\n          },\n          vm: {\n            bind: function () {\n              // stop walk\n              this.setting.stop = true;\n\n              // which component\n              var name = this.target,\n                vm = this.vm,\n                el = this.el,\n                // component reference\n                ref = el.getAttribute('q-ref') || false,\n                Child = vm.constructor.require(name),\n                data = Child.options.data,\n                options,\n                childVm;\n              options = {\n                el: el,\n                data: data,\n                _parent: vm\n              };\n              childVm = new Child(options);\n              vm._children.push(childVm);\n              ref && !function () {\n                var refs = vm.$[ref];\n                refs ? refs.length ? refs.push(childVm) : vm.$[ref] = [refs, childVm] : vm.$[ref] = childVm;\n              }();\n            }\n          },\n          'if': {\n            bind: function () {\n              // return if el is a template\n              if (!this.el.parentNode) return;\n              var tpl = this.el,\n                parentNode = tpl.parentNode,\n                ref = document.createComment('q-if'),\n                hasInit = false,\n                exist = true,\n                key = this.target,\n                namespace = this.namespace,\n                target = _.get(namespace, key),\n                readFilters = this.filters,\n                data = this.data(),\n                vm = this.vm;\n              this.setting.stop = true;\n              function _init(value) {\n                // no exist no bind\n                if (hasInit || !exist || !value) return;\n                hasInit = true;\n                vm._templateBind(tpl, {\n                  data: data,\n                  namespace: namespace,\n                  immediate: true\n                });\n              }\n              vm.$watch(target, function (value, oldVal) {\n                value = vm.applyFilters(value, readFilters, oldVal);\n                _init(value);\n                // need to init\n                if (value === exist) return;\n                // bind\n                if (value === true) {\n                  parentNode.replaceChild(tpl, ref);\n                  exist = value;\n                  // unbind\n                } else if (value === false) {\n                  parentNode.replaceChild(ref, tpl);\n                  exist = value;\n                }\n                _init(value);\n              }, typeof this.data(key) === 'object', true);\n            }\n          },\n          el: {\n            bind: function () {\n              this.vm.$$[this.target] = this.el;\n            }\n          },\n          repeat: __nested_webpack_require_41502__(10)\n        };\n\n        /***/\n      }, /* 10 */\n      /***/function (module, exports, __nested_webpack_require_49083__) {\n        var _ = __nested_webpack_require_49083__(1);\n        var methods = {\n          'default': {\n            // how to clean the dom\n            clean: function (parentNode, repeats) {\n              if (repeats.length) {\n                repeats.forEach(function (node) {\n                  // repeat element may has been remove\n                  node.parentNode === parentNode && parentNode.removeChild(node);\n                });\n                _.cleanData(repeats);\n                repeats.length = 0;\n              }\n            },\n            insert: function (parentNode, fragment, ref) {\n              parentNode.insertBefore(fragment, ref);\n            }\n          },\n          push: {\n            insert: function (parentNode, fragment, ref) {\n              parentNode.insertBefore(fragment, ref);\n            },\n            dp: function (data, patch) {\n              return patch.res;\n            }\n          },\n          splice: {\n            clean: function (parentNode, repeats, value, watchers) {\n              var i = value[0],\n                l = value[1],\n                target = value[2].$namespace(),\n                eles = repeats.splice(i, l);\n              eles.forEach(function (ele) {\n                parentNode.removeChild(ele);\n              });\n              // just splice one time\n              if (!value.done) {\n                splice(watchers, target, i, l);\n                value.done = true;\n              }\n              return true;\n            },\n            dp: function (data, patch) {\n              patch.args.push(data);\n              return patch.args;\n            }\n          }\n        };\n        function splice(watchers, target, i, l) {\n          var length = target.length,\n            subKey,\n            cur,\n            index,\n            newKey;\n          Object.keys(watchers).forEach(function (key) {\n            if (~key.indexOf(target)) {\n              subKey = key.substring(length + 1);\n              cur = subKey.split('.');\n              if (cur.length) {\n                index = +cur.shift();\n                if ((index -= l) >= i) {\n                  cur.unshift(index);\n                  cur.unshift(target);\n                  newKey = cur.join('.');\n                  watchers[newKey] = watchers[key];\n                  delete watchers[key];\n                }\n              }\n            }\n          });\n        }\n        exports.bind = function () {\n          var tpl = this.el,\n            setting = this.setting,\n            parentNode = tpl.parentNode,\n            key,\n            namespace,\n            target,\n            readFilters,\n            repeats,\n            ref,\n            vm;\n          // return\n          if (!parentNode || setting.stop) return;\n\n          // stop binding\n          setting.stop = true;\n          key = this.target;\n          namespace = this.namespace;\n          target = _.get(namespace, key);\n          readFilters = this.filters;\n          repeats = [];\n          ref = document.createComment('q-repeat');\n          vm = this.vm;\n          parentNode.replaceChild(ref, tpl);\n          vm.$watch(target, function (value, oldVal, patch) {\n            value = vm.applyFilters(value, readFilters);\n            // if value is undefined or null just return\n            if (value == null) return;\n            var method = !readFilters.length && patch ? patch.method : 'default',\n              dp = (methods[method] || {}).dp,\n              clean = (methods[method] || {}).clean,\n              insert = (methods[method] || {}).insert;\n\n            // if dp exists, proceess data\n            dp && (value = dp(value, patch));\n            if (clean && clean(parentNode, repeats, value, vm._watchers, target) === true) {\n              return;\n            }\n            var fragment = document.createDocumentFragment(),\n              itemNode;\n            value.forEach(function (obj, i) {\n              itemNode = _.clone(tpl);\n              vm._templateBind(itemNode, {\n                data: obj,\n                namespace: obj.$namespace(),\n                immediate: true\n              });\n              // TODO this must refactor\n              repeats.push(itemNode);\n              fragment.appendChild(itemNode);\n            });\n            insert && insert(parentNode, fragment, ref);\n            vm.$emit('repeat-render');\n          }, false, true);\n        };\n\n        /***/\n      }, /* 11 */\n      /***/function (module, exports, __nested_webpack_require_53527__) {\n        var parse = __nested_webpack_require_53527__(12),\n          _ = __nested_webpack_require_53527__(1);\n        module.exports = function (el, options) {\n          options = options || {};\n          var self = this,\n            directives = self.$options.directives,\n            index = options.index,\n            data = options.data || self,\n            namespace = options.namespace;\n          _.walk([el], function (node, res, setting) {\n            res.forEach(function (obj) {\n              var name = obj.name.substring(2),\n                directive = directives[name],\n                descriptors = parse(obj.value);\n              directive && descriptors.forEach(function (descriptor) {\n                var readFilters = self._makeReadFilters(descriptor.filters, self.data(namespace)),\n                  key = descriptor.target,\n                  target = _.get(namespace, key),\n                  update = _.isObject(directive) ? directive.update : directive,\n                  that = _.extend({\n                    el: node,\n                    vm: self,\n                    data: function (key) {\n                      return self.data(_.get(namespace, key));\n                    },\n                    namespace: namespace,\n                    setting: setting\n                  }, descriptor, {\n                    filters: readFilters\n                  }),\n                  tmp = that.data(key);\n                update && self.$watch(target, function (value, oldValue) {\n                  value = self.applyFilters(value, readFilters, oldValue);\n                  update.call(that, value, oldValue);\n                }, typeof tmp === 'object', _.alpaca ? false : typeof options.immediate === 'boolean' ? options.immediate : tmp !== undefined);\n                if (_.isObject(directive) && directive.bind) directive.bind.call(that);\n              });\n            });\n          });\n        };\n\n        /***/\n      }, /* 12 */\n      /***/function (module, exports, __nested_webpack_require_55505__) {\n        var cache = new (__nested_webpack_require_55505__(2))(1000),\n          tokens = [\n          // space\n          [/^ +/],\n          // arg\n          [/^([\\w\\-]+):/, function (captures, status) {\n            status.token.arg = captures[1];\n          }],\n          // function\n          [/^([\\w]+)\\((.+?)\\)/, function (captures, status) {\n            status.token.target = captures[1];\n            status.token.param = captures[2].split(/ *, */);\n          }],\n          // target\n          [/^([\\w\\-\\.\\$]+)/, function (captures, status) {\n            status.token.target = captures[1];\n          }],\n          // filter\n          [/^(?=\\|)/, function (captures, status) {\n            status.filter = true;\n          }],\n          // next\n          [/^,/, function (captures, status, res) {\n            res.push(status.token);\n            status.token = {\n              filters: []\n            };\n          }]],\n          filterREG = /^(.+?)(?=,|$)/,\n          filterTokens = [\n          // space\n          [/^ +/],\n          // filter\n          [/^\\| *([\\w\\-\\!]+)/, function (captures, filters) {\n            filters.push([captures[1]]);\n          }],\n          // string\n          [/^(['\"])(((\\\\['\"])?([^\\1])*)+)\\1/, function (captures, filters) {\n            filters[filters.length - 1].push(captures[3]);\n          }],\n          // arg\n          [/^([\\w\\-\\$]+)/, function (captures, filters) {\n            filters[filters.length - 1].push(captures[1]);\n          }]];\n        /**\r\n         * click: onclick | filter1 | filter2\r\n         * click: onclick , keydown: onkeydown\r\n         * click: onclick(this)\r\n         * click: onclick(e, this)\r\n         * value1 | filter1 | filter2\r\n         * value - 1 | filter1 | filter2   don't support\r\n         */\n        function parse(str) {\n          var name = str,\n            hit = cache.get(name);\n          if (hit) return hit;\n          var res = [],\n            captures,\n            i,\n            l = tokens.length,\n            foo,\n            // if has token or not\n            has = false,\n            status = {\n              // if in filter or not\n              filter: false,\n              // just token object\n              token: {\n                filters: []\n              }\n            };\n          while (str.length) {\n            for (i = 0; i < l; i++) {\n              if (captures = tokens[i][0].exec(str)) {\n                var has = true;\n                var foo = tokens[i][1];\n                foo && foo(captures, status, res);\n                str = str.replace(tokens[i][0], '');\n                if (status.filter) {\n                  captures = filterREG.exec(str);\n                  parseFilter(captures[0].trim(), status.token);\n                  str = str.replace(filterREG, '');\n                  status.filter = false;\n                }\n                break;\n              }\n            }\n            if (has) {\n              has = false;\n            } else {\n              throw new Error('Syntax error at: ' + str);\n            }\n          }\n          res.push(status.token);\n          cache.put(name, res);\n          return res;\n        }\n        function parseFilter(str, token) {\n          var i,\n            l = filterTokens.length,\n            has = false;\n          while (str.length) {\n            for (i = 0; i < l; i++) {\n              var captures = filterTokens[i][0].exec(str);\n              if (captures) {\n                var has = true;\n                var foo = filterTokens[i][1];\n                foo && foo(captures, token.filters);\n                str = str.replace(filterTokens[i][0], '');\n                break;\n              }\n            }\n            if (has) {\n              has = false;\n            } else {\n              throw new Error('Syntax error at: ' + str);\n            }\n          }\n        }\n        module.exports = parse;\n\n        /***/\n      }\n      /******/])\n    );\n  });\n\n  ;\n}).call(module.exports);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2Utc3JjL2pzL1EuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBR0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBR0E7QUFFQTs7QUFHQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBR0E7QUFBQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFHQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQVFBO0FBT0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWx1Y2t5c2hpcC8uL3NvdXJjZS1zcmMvanMvUS5qcz8wZmM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gKiBRLmpzIHYxLjAuMTJcclxuICogSW5zcGlyZWQgZnJvbSB2dWUuanNcclxuICogKGMpIDIwMTYgRGFuaWVsIFlhbmdcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuIFxyXG4vKipcclxuICogSnVzdCBzdXBwb3J0IG1vZGVybiBicm93c2VyXHJcbiAqL1xyXG4gXHJcbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XHJcbiAgICBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcbiAgICBlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xyXG4gICAgZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgZXhwb3J0c1tcIlFcIl0gPSBmYWN0b3J5KCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcm9vdFtcIlFcIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xyXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxyXG4vKioqKioqLyAgICAvLyBUaGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovICAgIHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbiBcclxuLyoqKioqKi8gICAgLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gICAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xyXG4gXHJcbi8qKioqKiovICAgICAgICAvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gICAgICAgIGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxyXG4vKioqKioqLyAgICAgICAgICAgIHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG4gXHJcbi8qKioqKiovICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxyXG4vKioqKioqLyAgICAgICAgdmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xyXG4vKioqKioqLyAgICAgICAgICAgIGV4cG9ydHM6IHt9LFxyXG4vKioqKioqLyAgICAgICAgICAgIGlkOiBtb2R1bGVJZCxcclxuLyoqKioqKi8gICAgICAgICAgICBsb2FkZWQ6IGZhbHNlXHJcbi8qKioqKiovICAgICAgICB9O1xyXG4gXHJcbi8qKioqKiovICAgICAgICAvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cclxuLyoqKioqKi8gICAgICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xyXG4gXHJcbi8qKioqKiovICAgICAgICAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovICAgICAgICBtb2R1bGUubG9hZGVkID0gdHJ1ZTtcclxuIFxyXG4vKioqKioqLyAgICAgICAgLy8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcclxuLyoqKioqKi8gICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcclxuLyoqKioqKi8gICAgfVxyXG4gXHJcbiBcclxuLyoqKioqKi8gICAgLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcclxuLyoqKioqKi8gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcclxuIFxyXG4vKioqKioqLyAgICAvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4gXHJcbi8qKioqKiovICAgIC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XHJcbiBcclxuLyoqKioqKi8gICAgLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXHJcbi8qKioqKiovICAgIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG4vKioqKioqLyB9KVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKioqKioqLyAoW1xyXG4vKiAwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG4gXHJcbiAgICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLFxyXG4gICAgICAgIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLFxyXG4gICAgICAgIGZhY3RvcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpXHJcbiBcclxuICAgIF8uZXh0ZW5kKHV0aWxzLCBfKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSh1dGlscyk7XHJcbiBcclxuIFxyXG4vKioqLyB9LFxyXG4vKiAxICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG4gXHJcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9LFxyXG4gICAgICAgIGRlZmVyID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQsXHJcbiAgICAgICAgY2FjaGUgPSBuZXcgKF9fd2VicGFja19yZXF1aXJlX18oMikpKDEwMDApLFxyXG4gICAgICAgIC8vIHByaW9yaXR5IGRpcmVjdGl2ZXNcclxuICAgICAgICBwcmlvcml0aWVzID0gWyd2bScsICdyZXBlYXQnLCAnaWYnXSxcclxuICAgICAgICBfcXRpZCA9IDAsXHJcbiAgICAgICAgX3NsaWNlID0gW10uc2xpY2UsXHJcbiAgICAgICAgX2FscGFjYSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0sXHJcbiAgICAgICAgc2xpY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBfc2xpY2UuY2FsbChkb2N1bWVudC5ib2R5LmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zbGljZTtcclxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpID0gaSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKTtcclxuIFxyXG4gICAgX2FscGFjYSAmJiAoX2FscGFjYSA9IF9hbHBhY2EuZ2V0QXR0cmlidXRlKCdhbHBhY2EnKSk7XHJcbiBcclxuICAgIGZ1bmN0aW9uIF9sb29wUHJpb3JpdHkoZWwsIHJlcywgc2V0dGluZykge1xyXG4gICAgICAgIHZhciBhdHRyLCB0bXA7XHJcbiBcclxuICAgICAgICAvLyBUT0RPIG5lZWQgb3B0aW1pemF0aW9uXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBwcmlvcml0aWVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICBhdHRyID0gJ3EtJyArIHByaW9yaXRpZXNbal07XHJcbiAgICAgICAgICAgIGlmICh0bXAgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cikpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBhdHRyLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0bXBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gXHJcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XHJcbiAgICAgICAgICAgICAgICAvLyBoYXMgcHJpb3JpdHkgZGlyZWN0aXZlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuIFxyXG4gICAgZnVuY3Rpb24gd2FsaygkZWwsIGNiLCBzZXR0aW5nKSB7XHJcbiAgICAgICAgc2V0dGluZyA9IHNldHRpbmcgfHwge307XHJcbiAgICAgICAgdmFyIGksIGosIGwsIGVsLCBhdHRzLCByZXMsIHF0aWQ7XHJcbiAgICAgICAgZm9yIChpID0gMDsgZWwgPSAkZWxbaSsrXTspIHtcclxuICAgICAgICAgICAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRzID0gZWwuYXR0cmlidXRlcztcclxuICAgICAgICAgICAgICAgIHJlcyA9IFtdO1xyXG4gXHJcbiAgICAgICAgICAgICAgICAvLyBsb29wIHRoZSBwcmlvcml0eSBkaXJlY3RpdmVcclxuICAgICAgICAgICAgICAgIGlmICghX2xvb3BQcmlvcml0eShlbCwgcmVzLCBzZXR0aW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb3Agb3RoZXIgZGlyZWN0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbCA9IGF0dHMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHNbal0ubmFtZS5pbmRleE9mKCdxLScpID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYXR0c1tqXS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhdHRzW2pdLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlcy5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY2IoZWwsIHJlcywgc2V0dGluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVsLmNoaWxkTm9kZXMubGVuZ3RoICYmICFzZXR0aW5nLnN0b3ApIHdhbGsoc2xpY2UuY2FsbChlbC5jaGlsZE5vZGVzLCAwKSwgY2IsIHNldHRpbmcpO1xyXG4gICAgICAgICAgICAvLyByZXNldCBzdG9wXHJcbiAgICAgICAgICAgIHNldHRpbmcuc3RvcCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuIFxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgc2xpY2U6IHNsaWNlLFxyXG4gICAgICAgIG5vb3A6IG5vb3AsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cm9uZ30gY2xzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChlbCwgY2xzKSB7XHJcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXIgPSAnICcgKyAoZWwuY2xhc3NOYW1lIHx8ICcnKSArICcgJztcclxuICAgICAgICAgICAgICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IChjdXIgKyBjbHMpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cm9uZ30gY2xzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbCwgY2xzKSB7XHJcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXIgPSAnICcgKyAoZWwuY2xhc3NOYW1lIHx8ICcnKSArICcgJyxcclxuICAgICAgICAgICAgICAgICAgICB0YXIgPSAnICcgKyBjbHMgKyAnICc7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gY3VyLnRyaW0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbm9leGlzdDogZnVuY3Rpb24gKHZtLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2Fybih2bSk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsdGVyICcgKyBuYW1lICsgJyBoYXNuXFwndCBpbXBsZW1lbnRlZC4nKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdhcm46IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSA/IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9IDogbm9vcDtcclxuICAgICAgICB9KCksXHJcbiAgICAgICAgaXNPYmplY3Q6IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0VGljazogZnVuY3Rpb24gKGNiLCBjdHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN0eCA/XHJcbiAgICAgICAgICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7IGNiLmNhbGwoY3R4KSB9LCAwKSA6XHJcbiAgICAgICAgICAgICAgICBkZWZlcihjYiwgMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXRcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAobmFtZXNwYWNlLCBrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgICAgICBuYW1lc3BhY2UgJiYgYXJyLnB1c2gobmFtZXNwYWNlKTtcclxuICAgICAgICAgICAga2V5ICYmIGFyci5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnIuam9pbignLicpLnJlcGxhY2UoL14oLitcXC4pP1xcJHRvcFxcLi8sICcnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdhbGs6IHdhbGssXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYWxwYWNhXHJcbiAgICAgICAgICoganVzdCBhIGZsYWdcclxuICAgICAgICAgKi9cclxuICAgICAgICBhbHBhY2E6ICEhX2FscGFjYVxyXG4gICAgfTtcclxuIFxyXG4gXHJcbi8qKiovIH0sXHJcbi8qIDIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcbiBcclxuICAgIC8qKlxyXG4gICAgICoganVzdCBhIGNvcHkgb2Y6IGh0dHBzOi8vZ2l0aHViLmNvbS95eXg5OTA4MDMvdnVlL2Jsb2IvbWFzdGVyL3NyYy9jYWNoZS5qc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuIFxyXG4gICAgZnVuY3Rpb24gQ2FjaGUgKGxpbWl0KSB7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2tleW1hcCA9IHt9O1xyXG4gICAgfVxyXG4gXHJcbiAgICB2YXIgcCA9IENhY2hlLnByb3RvdHlwZTtcclxuIFxyXG4gICAgLyoqXHJcbiAgICAgKiBQdXQgPHZhbHVlPiBpbnRvIHRoZSBjYWNoZSBhc3NvY2lhdGVkIHdpdGggPGtleT4uXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlbnRyeSB3aGljaCB3YXMgcmVtb3ZlZCB0byBtYWtlIHJvb20gZm9yXHJcbiAgICAgKiB0aGUgbmV3IGVudHJ5LiBPdGhlcndpc2UgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxyXG4gICAgICogKGkuZS4gaWYgdGhlcmUgd2FzIGVub3VnaCByb29tIGFscmVhZHkpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAqIEByZXR1cm4ge0VudHJ5fHVuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gXHJcbiAgICBwLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG4gICAgICAgICAgICBrZXk6a2V5LFxyXG4gICAgICAgICAgICB2YWx1ZTp2YWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9rZXltYXBba2V5XSA9IGVudHJ5O1xyXG4gICAgICAgIGlmICh0aGlzLnRhaWwpIHtcclxuICAgICAgICAgICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnk7XHJcbiAgICAgICAgICAgIGVudHJ5Lm9sZGVyID0gdGhpcy50YWlsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcclxuICAgICAgICBpZiAodGhpcy5zaXplID09PSB0aGlzLmxpbWl0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoaWZ0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zaXplKys7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuIFxyXG4gICAgLyoqXHJcbiAgICAgKiBQdXJnZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCAob2xkZXN0KSBlbnRyeSBmcm9tIHRoZVxyXG4gICAgICogY2FjaGUuIFJldHVybnMgdGhlIHJlbW92ZWQgZW50cnkgb3IgdW5kZWZpbmVkIGlmIHRoZVxyXG4gICAgICogY2FjaGUgd2FzIGVtcHR5LlxyXG4gICAgICovXHJcbiBcclxuICAgIHAuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGlmIChlbnRyeSkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV3ZXI7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZC5vbGRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgZW50cnkubmV3ZXIgPSBlbnRyeS5vbGRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5fa2V5bWFwW2VudHJ5LmtleV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgIH07XHJcbiBcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFuZCByZWdpc3RlciByZWNlbnQgdXNlIG9mIDxrZXk+LiBSZXR1cm5zIHRoZSB2YWx1ZVxyXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIDxrZXk+IG9yIHVuZGVmaW5lZCBpZiBub3QgaW4gY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5FbnRyeVxyXG4gICAgICogQHJldHVybiB7RW50cnl8Kn1cclxuICAgICAqL1xyXG4gXHJcbiAgICBwLmdldCA9IGZ1bmN0aW9uIChrZXksIHJldHVybkVudHJ5KSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fa2V5bWFwW2tleV07XHJcbiAgICAgICAgaWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHJldHVybjtcclxuICAgICAgICBpZiAoZW50cnkgPT09IHRoaXMudGFpbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuRW50cnkgP1xyXG4gICAgICAgICAgICAgICAgZW50cnkgOlxyXG4gICAgICAgICAgICAgICAgZW50cnkudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAvLyBIRUFELS0tLS0tLS0tLS0tLS1UQUlMXHJcbiAgICAgIC8vICAgPC5vbGRlciAgIC5uZXdlcj5cclxuICAgICAgLy8gIDwtLS0gYWRkIGRpcmVjdGlvbiAtLVxyXG4gICAgICAvLyAgIEEgIEIgIEMgIDxEPiAgRVxyXG4gICAgICAgIGlmIChlbnRyeS5uZXdlcikge1xyXG4gICAgICAgICAgICBpZiAoZW50cnkgPT09IHRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV3ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjsgLy8gQyA8LS0gRS5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVudHJ5Lm9sZGVyKSB7XHJcbiAgICAgICAgICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7IC8vIEMuIC0tPiBFXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVudHJ5Lm5ld2VyID0gdW5kZWZpbmVkOyAvLyBEIC0teFxyXG4gICAgICAgIGVudHJ5Lm9sZGVyID0gdGhpcy50YWlsOyAvLyBELiAtLT4gRVxyXG4gICAgICAgIGlmICh0aGlzLnRhaWwpIHtcclxuICAgICAgICAgICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnk7IC8vIEUuIDwtLSBEXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xyXG4gICAgICAgIHJldHVybiByZXR1cm5FbnRyeSA/XHJcbiAgICAgICAgICAgIGVudHJ5IDpcclxuICAgICAgICAgICAgZW50cnkudmFsdWU7XHJcbiAgICB9XHJcbiBcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2FjaGU7XHJcbiBcclxuIFxyXG4vKioqLyB9LFxyXG4vKiAzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG4gXHJcbiAgICB2YXIgREVMRUdBVE9SX0NBTExCQUNLU19LRVkgPSAnX19jYnNfXycsXHJcbiAgICAgICAgTk9fREVMRUdBVE9SID0ge1xyXG4gICAgICAgICAgICAvLyBwcmV2ZW50IG1vdXNlb3ZlciB0cmlnZ2VyIG1vcmUgdGhhbiBvbmUgdGltZVxyXG4gICAgICAgICAgICBtb3VzZW92ZXI6IHRydWUsXHJcbiAgICAgICAgICAgIGNoYW5nZTogdHJ1ZSxcclxuICAgICAgICAgICAgaW5wdXQ6IHRydWUsXHJcbiAgICAgICAgICAgIHBvcnBlcnR5Y2hhbmdlOiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgIHZhciBfZXh0ZW5kID0gZnVuY3Rpb24gKHRhcmdldCwgc3Jjcykge1xyXG4gICAgICAgICAgICBzcmNzID0gW10uc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsID0gc3Jjcy5sZW5ndGgsIHNyYywga2V5O1xyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3JjID0gc3Jjc1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHNyYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc3JjW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9leHBhbmRvID0gJ1FEYXRhVWlkJyxcclxuICAgICAgICBfdWlkID0gMCxcclxuICAgICAgICBfbWFwID0ge307XHJcbiBcclxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYSAhPT0gYiAmJiBhLmNvbnRhaW5zKGIpO1xyXG4gICAgfVxyXG4gXHJcbiAgICBmdW5jdGlvbiBkYXRhKGVsLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHVpZCA9IGVsW19leHBhbmRvXSA9IGVsW19leHBhbmRvXSB8fCArK191aWQsXHJcbiAgICAgICAgICAgIGRhdGEgPSBfbWFwW3VpZF0gPSBfbWFwW3VpZF0gfHwge307XHJcbiAgICAgICAgLy8gc2V0IERhdGFcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGRhdGFba2V5XTtcclxuICAgICAgICByZXR1cm4gKGRhdGFba2V5XSA9IHZhbHVlKTtcclxuICAgIH1cclxuIFxyXG4gICAgZnVuY3Rpb24gYWRkKGVsLCBldnQsIGZuKSB7XHJcbiAgICAgICAgZXZ0LnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGUsIGZuLCBmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiBcclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCAwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRhaW5zOiBjb250YWlucyxcclxuICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgIGNsZWFuRGF0YTogZnVuY3Rpb24gKGVscykge1xyXG4gICAgICAgICAgICB2YXIgdWlkXHJcbiAgICAgICAgICAgIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVpZCA9IGVsW19leHBhbmRvXTtcclxuICAgICAgICAgICAgICAgIC8vIGhhcyBkYXRhXHJcbiAgICAgICAgICAgICAgICB1aWQgJiYgKHVpZCBpbiBfbWFwKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChkZWxldGUgX21hcFt1aWRdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChlbCwgZXZ0LCBmbiwgdm0pIHtcclxuICAgICAgICAgICAgaWYgKCF2bSB8fCBOT19ERUxFR0FUT1JbZXZ0XSkge1xyXG4gICAgICAgICAgICAgICAgYWRkKGVsLCBldnQsIGZuKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciAkZWwgPSB2bS4kZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgY2JzID0gZGF0YSgkZWwsIERFTEVHQVRPUl9DQUxMQkFDS1NfS0VZKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2JzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSgkZWwsIERFTEVHQVRPUl9DQUxMQkFDS1NfS0VZLCBjYnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZCgkZWwsIGV2dCwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gY2IuZm4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBjYi5lbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhlbCwgdGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmNhbGwoZWwsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHB1c2hcclxuICAgICAgICAgICAgICAgIGNicy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBlbDogZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgZm46IGZuXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWwsIGV2dCwgZm4pIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGZuLCBmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKGVsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIF9leHRlbmQodGhpcywgdGFyZ2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuIF9leHRlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gXHJcbiBcclxuLyoqKi8gfSxcclxuLyogNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuIFxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoXykge1xyXG4gXHJcbiAgICAgICAgdmFyIFNlZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLFxyXG4gICAgICAgICAgICBldmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxyXG4gICAgICAgICAgICBNQVJLID0gL1xce1xceyguKz8pXFx9XFx9LyxcclxuICAgICAgICAgICAgbWVyZ2VPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KS5tZXJnZU9wdGlvbnMsXHJcbiAgICAgICAgICAgIGNsYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpLFxyXG4gICAgICAgICAgICBfZG9jID0gZG9jdW1lbnQ7XHJcbiBcclxuICAgICAgICBmdW5jdGlvbiBfaW5Eb2MoZWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfLmNvbnRhaW5zKF9kb2MuZG9jdW1lbnRFbGVtZW50LCBlbGUpO1xyXG4gICAgICAgIH1cclxuIFxyXG4gICAgICAgIC8vIGxpZmVjeWNsZTogY3JlYXRlZCAtPiBjb21waWxlZFxyXG4gXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUVxyXG4gICAgICAgICAqIEBjbGFzc1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUShvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV4cG9ydHMgdXRpbHNcclxuICAgICAgICBRLl8gPSBfO1xyXG4gICAgICAgIFEub3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgZGlyZWN0aXZlczogX193ZWJwYWNrX3JlcXVpcmVfXyg5KSxcclxuICAgICAgICAgICAgZmlsdGVyczoge31cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgRWxlbWVudH0gc2VsZWN0b3JcclxuICAgICAgICAgKiBAcmV0dXJuIHtRfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFEuZ2V0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGUgPSBfLmZpbmQoc2VsZWN0b3IpWzBdO1xyXG4gICAgICAgICAgICBpZiAoZWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5kYXRhKGVsZSwgJ1FJJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMoeyBlbDogc2VsZWN0b3IgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGFsbFxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUS5hbGwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfLmZpbmQob3B0aW9ucy5lbCkubWFwKGZ1bmN0aW9uIChlbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc2VsZihfLmV4dGVuZChvcHRpb25zLCB7IGVsOiBlbGUgfSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF8uZXh0ZW5kKFEsIGNsYXMpO1xyXG4gICAgICAgIF8uZXh0ZW5kKFEucHJvdG90eXBlLCB7XHJcbiAgICAgICAgICAgIF9pbml0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRlbCA9IG9wdGlvbnMuZWwgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuZWwgPT09ICdzdHJpbmcnID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZmluZChvcHRpb25zLmVsKVswXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVsO1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCByZWZlcmVuY2VzXHJcbiAgICAgICAgICAgICAgICB0aGlzLiQkID0ge307XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgcGFyZW50IHZtXHJcbiAgICAgICAgICAgICAgICB0aGlzLiRwYXJlbnQgPSBvcHRpb25zLl9wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgLy8gbGlmZWN5Y2xlIHN0YXRlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0NvbXBpbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0F0dGFjaGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1JlYWR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgYm9va2tlZXBpbmdcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2F0Y2hlcnMgPSB7fTtcclxuIFxyXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50c1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudHMgcmVmZXJlbmNlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kID0ge307XHJcbiBcclxuICAgICAgICAgICAgICAgIFNlZWQuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2RhdGEgPSBvcHRpb25zLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIGRhdGEgYW5kIHNjb3BlIGluaGVyaXRhbmNlLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFNjb3BlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGNyZWF0ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2NyZWF0ZWQnKTtcclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGNvbXBpbGF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSB0aGUgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgICAgICBfLmRhdGEodGhpcy4kZWwsICdRSScsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG1vdW50KHRoaXMuJGVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgJG9uOiBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XHJcbiAgICAgICAgICAgICAgICAodGhpcy5fZXZlbnRzW2V2ZW50XSB8fCAodGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtdKSlcclxuICAgICAgICAgICAgICAgICAgICAucHVzaChmbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gICAgICAgICAgICAgKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICRvbmNlOiBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLiRvZmYoZXZlbnQsIG9uKTtcclxuICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb24uZm4gPSBmbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuJG9uKGV2ZW50LCBvbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfSxcclxuIFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICAgICAgICAgICAgICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAgICAgICAgICAgKi9cclxuIFxyXG4gICAgICAgICAgICAkb2ZmOiBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2JzLCBjYiwgaTtcclxuICAgICAgICAgICAgICAgIC8vIGFsbCBldmVudFxyXG4gICAgICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBldmVudFxyXG4gICAgICAgICAgICAgICAgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcclxuICAgICAgICAgICAgICAgIGlmICghY2JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgaSA9IGNicy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IgPSBjYnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXYXRjaCBhbiBleHByZXNzaW9uLCB0cmlnZ2VyIGNhbGxiYWNrIHdoZW4gaXRzXHJcbiAgICAgICAgICAgICAqIHZhbHVlIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBleHBcclxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbZGVlcF1cclxuICAgICAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbaW1tZWRpYXRlXVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB1bndhdGNoRm5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICR3YXRjaDogZnVuY3Rpb24gKGV4cCwgY2IsIGRlZXAsIGltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGRlZXAgPyBleHAgKyAnKipkZWVwKionIDogZXhwO1xyXG4gICAgICAgICAgICAgICAgKHRoaXMuX3dhdGNoZXJzW2tleV0gfHwgKHRoaXMuX3dhdGNoZXJzW2tleV0gPSBbXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnB1c2goY2IpO1xyXG4gICAgICAgICAgICAgICAgaW1tZWRpYXRlICYmIGNiKHRoaXMuZGF0YShleHApKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVHJpZ2dlciBhbiBldmVudCBvbiBzZWxmLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgJGVtaXQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IF8uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzLmVtaXQuY2FsbCh0aGlzLCBlLCBfLnNsaWNlLmNhbGwoYXJncywgMCkpO1xyXG4gICAgICAgICAgICAgICAgLy8gZW1pdCBkYXRhIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlLmluZGV4T2YoJ2RhdGE6JykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gZS5zdWJzdHJpbmcoNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmNhbGxDaGFuZ2UuY2FsbCh0aGlzLCBlLCBfLnNsaWNlLmNhbGwoYXJncywgMCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlLmluZGV4T2YoJ2RlZXA6JykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gZS5zdWJzdHJpbmcoNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmNhbGxEZWVwLmNhbGwodGhpcywgZSwgXy5zbGljZS5jYWxsKGFyZ3MsIDApKTtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmVtaXQuY2FsbCh0aGlzLCAnZGF0YWNoYW5nZScsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXR1cCB0aGUgc2NvcGUgb2YgYW4gaW5zdGFuY2UsIHdoaWNoIGNvbnRhaW5zOlxyXG4gICAgICAgICAgICAgKiAtIG9ic2VydmVkIGRhdGFcclxuICAgICAgICAgICAgICogLSBjb21wdXRlZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAqIC0gdXNlciBtZXRob2RzXHJcbiAgICAgICAgICAgICAqIC0gbWV0YSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfaW5pdFNjb3BlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0TWV0aG9kcygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXR1cCBpbnN0YW5jZSBtZXRob2RzLiBNZXRob2RzIG11c3QgYmUgYm91bmQgdG8gdGhlXHJcbiAgICAgICAgICAgICAqIGluc3RhbmNlIHNpbmNlIHRoZXkgbWlnaHQgYmUgY2FsbGVkIGJ5IGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAqIGluaGVyaXRpbmcgdGhlbS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9pbml0TWV0aG9kczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLiRvcHRpb25zLm1ldGhvZHMsIGtleTtcclxuICAgICAgICAgICAgICAgIGlmIChtZXRob2RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gbWV0aG9kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBtZXRob2RzW2tleV0uYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiBcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldCBpbnN0YW5jZSB0YXJnZXQgZWxlbWVudCBhbmQga2ljayBvZmYgdGhlIGNvbXBpbGF0aW9uXHJcbiAgICAgICAgICAgICAqIHByb2Nlc3MuIFRoZSBwYXNzZWQgaW4gYGVsYCBjYW4gYmUgYSB0ZW1wbGF0ZSBzdHJpbmcsIGFuXHJcbiAgICAgICAgICAgICAqIGV4aXN0aW5nIEVsZW1lbnQsIG9yIGEgRG9jdW1lbnRGcmFnbWVudCAoZm9yIGJsb2NrXHJcbiAgICAgICAgICAgICAqIGluc3RhbmNlcykuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcclxuICAgICAgICAgICAgICogQHB1YmxpY1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgJG1vdW50OiBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0NvbXBpbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ud2FybignJG1vdW50KCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gZm9yIHRlbXBsYXRlIHx8IHdlIG1heSBub3QgZG8gZm9yIHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGUoZWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNDb21waWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsSG9vaygnY29tcGlsZWQnKTtcclxuICAgICAgICAgICAgICAgIGlmIChfaW5Eb2ModGhpcy4kZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZHkoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kb25jZSgnaG9vazphdHRhY2hlZCcsIHRoaXMuX3JlYWR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuIFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogcmVhZHlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9yZWFkeTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxIb29rKCdyZWFkeScpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVHJhbnNjbHVkZSwgY29tcGlsZSBhbmQgbGluayBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBJZiBhIHByZS1jb21waWxlZCBsaW5rZXIgaXMgYXZhaWxhYmxlLCB0aGF0IG1lYW5zIHRoZVxyXG4gICAgICAgICAgICAgKiBwYXNzZWQgaW4gZWxlbWVudCB3aWxsIGJlIHByZS10cmFuc2NsdWRlZCBhbmQgY29tcGlsZWRcclxuICAgICAgICAgICAgICogYXMgd2VsbCAtIGFsbCB3ZSBuZWVkIHRvIGRvIGlzIHRvIGNhbGwgdGhlIGxpbmtlci5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2FsbCB0cmFuc2NsdWRlL2NvbXBpbGUvbGluayBoZXJlLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfY29tcGlsZTogZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zY2x1ZShlbCwgdGhpcy4kb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQcm9jZXNzIGFuIGVsZW1lbnQgb3IgYSBEb2N1bWVudEZyYWdtZW50IGJhc2VkIG9uIGFcclxuICAgICAgICAgICAgICogaW5zdGFuY2Ugb3B0aW9uIG9iamVjdC4gVGhpcyBhbGxvd3MgdXMgdG8gdHJhbnNjbHVkZVxyXG4gICAgICAgICAgICAgKiBhIHRlbXBsYXRlIG5vZGUvZnJhZ21lbnQgYmVmb3JlIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkLFxyXG4gICAgICAgICAgICAgKiBzbyB0aGUgcHJvY2Vzc2VkIGZyYWdtZW50IGNhbiB0aGVuIGJlIGNsb25lZCBhbmQgcmV1c2VkXHJcbiAgICAgICAgICAgICAqIGluIHYtcmVwZWF0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0cmFuc2NsdWU6IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgLy8ganVzdCBiaW5kIHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZUJpbmQoZWwsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBiaW5kIHJlbmRlcmVkIHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGVtcGxhdGVCaW5kOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSxcclxuIFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVHJpZ2dlciBhbGwgaGFuZGxlcnMgZm9yIGEgaG9va1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaG9va1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX2NhbGxIb29rOiBmdW5jdGlvbiAoaG9vaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy4kb3B0aW9uc1tob29rXTtcclxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnaG9vazonICsgaG9vayk7XHJcbiAgICAgICAgICAgIH0sXHJcbiBcclxuICAgICAgICAgICAgX21ha2VSZWFkRmlsdGVyczogZnVuY3Rpb24gKG5hbWVzLCAkdGhpcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lcy5sZW5ndGgpIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJzID0gdGhpcy4kb3B0aW9ucy5maWx0ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWVzLm1hcChmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBfLnNsaWNlLmNhbGwoYXJncywgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBhcmdzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IChmaWx0ZXJzW25hbWVdID8gKGZpbHRlcnNbbmFtZV0ucmVhZCB8fCBmaWx0ZXJzW25hbWVdKSA6IF8ubm9leGlzdChzZWxmLCBuYW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgb2xkVmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IG1vZGlmeSBhcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGlzQXJncyA9IFt2YWx1ZV0uY29uY2F0KGFyZ3MgfHwgW10pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXNBcmdzLmluZGV4T2YoJyR0aGlzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNBcmdzLnB1c2gob2xkVmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSAkdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAofmkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNBcmdzW2ldID0gJHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3MgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLmFwcGx5KHNlbGYsIHRoaXNBcmdzKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLmNhbGwoc2VsZiwgdmFsdWUsIG9sZFZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBcHBseSBmaWx0ZXJzIHRvIGEgdmFsdWVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4geyp9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBhcHBseUZpbHRlcnM6IGZ1bmN0aW9uICh2YWx1ZSwgZmlsdGVycywgb2xkVmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlcnMgfHwgIWZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmaWx0ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmlsdGVyc1tpXS5jYWxsKHRoaXMsIHZhbHVlLCBvbGRWYWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiBcclxuICAgICAgICBfLmV4dGVuZChRLnByb3RvdHlwZSwgU2VlZC5wcm90b3R5cGUpO1xyXG4gXHJcbiAgICAgICAgcmV0dXJuIFE7XHJcbiAgICB9O1xyXG4gXHJcbiBcclxuLyoqKi8gfSxcclxuLyogNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuIFxyXG4gICAgdmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG4gXHJcbiAgICAvKipcclxuICAgICAqIHByZWZpeCBkYXRhXHJcbiAgICAgKiBAcGFyYW0ge0RhdGEgfHwgRGF0YUFycmF5fSB1cFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB0cmlnZ2VyIG9yIG5vdFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfcHJlZml4KHVwLCBrZXksIHZhbHVlLCB0cmlnZ2VyKSB7XHJcbiAgICAgICAgdmFyIHRvcCA9IHVwLl90b3AsXHJcbiAgICAgICAgICAgIGlzQXJyYXkgPSBfaXNBcnJheSh2YWx1ZSksXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIHVwOiB1cCxcclxuICAgICAgICAgICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBrZXkgKyAnJyxcclxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IGlzQXJyYXkgPyBmYWxzZSA6IHRyaWdnZXJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gb2xkIHZhbHVlXHJcbiAgICAgICAgICAgIG9sZFZhbCA9IHRvcC5kYXRhID8gdG9wLmRhdGEodXAuJG5hbWVzcGFjZShrZXkpKSA6IHVuZGVmaW5lZDtcclxuIFxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHVwW2tleV0gPSAgIGlzQXJyYXkgP1xyXG4gICAgICAgICAgICAgICAgbmV3IERhdGFBcnJheShvcHRpb25zKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGEob3B0aW9ucyk7XHJcbiBcclxuICAgICAgICAgICAgLy8gdHJpZ2dlciBkYXRhIGNoYW5nZVxyXG4gICAgICAgICAgICB0cmlnZ2VyICYmIHVwLiRjaGFuZ2UodXAuJG5hbWVzcGFjZShrZXkpLCB1cFtrZXldLCBvbGRWYWwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB1cFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgZGF0YSBjaGFuZ2VcclxuICAgICAgICAgICAgdHJpZ2dlciAmJiB1cC4kY2hhbmdlKHVwLiRuYW1lc3BhY2Uoa2V5KSwgdmFsdWUsIG9sZFZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKH51cC5fa2V5cy5pbmRleE9mKGtleSkpKSB1cC5fa2V5cy5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiBcclxuICAgIGZ1bmN0aW9uIF9pc0FycmF5KG9iaikge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgfHwgb2JqIGluc3RhbmNlb2YgRGF0YUFycmF5O1xyXG4gICAgfVxyXG4gXHJcbiAgICBmdW5jdGlvbiBfZ2V0TGVuZ3RoKGtleXMpIHtcclxuICAgICAgICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ251bWJlcic7XHJcbiAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgfVxyXG4gXHJcbiAgICAvKipcclxuICAgICAqIERhdGFcclxuICAgICAqIEBjbGFzc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRGF0YShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBvcHRpb25zLmRhdGEsXHJcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zLmRhdGEgfHwge30pXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleS5pbmRleE9mKCdfJykgIT09IDA7IH0pXHJcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gK251bSArICcnID09PSBudW0gPyArbnVtIDogbnVtO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xyXG4gXHJcbiAgICAgICAgXy5leHRlbmQodGhpcywgZGF0YSk7XHJcbiBcclxuICAgICAgICAvLyBhbGwga2V5IG5lZWQgdG8gdHJhdmVyc2VcclxuICAgICAgICB0aGlzLl9rZXlzID0ga2V5cztcclxuICAgICAgICAvLyBwYXJlbnQgZGF0YSBjb250YWluZXJcclxuICAgICAgICB0aGlzLl91cCA9IG9wdGlvbnMudXA7XHJcbiAgICAgICAgLy8gdGhlIG1vc3QgdG9wIHBhcmVudCBkYXRhIGNvbnRhaW5lclxyXG4gICAgICAgIHRoaXMuX3RvcCA9IG9wdGlvbnMudG9wIHx8IHRoaXM7XHJcbiAgICAgICAgLy8gdGhlIG5hbWVzcGFjZSBvZiBkYXRhXHJcbiAgICAgICAgdGhpcy5fbmFtZXNwYWNlID0gb3B0aW9ucy5uYW1lc3BhY2UgfHwgJyc7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgX3ByZWZpeChzZWxmLCBrZXksIGRhdGFba2V5XSwgb3B0aW9ucy50cmlnZ2VyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBpZiBpdCBpcyBhIGFycmF5XHJcbiAgICAgICAgX2lzQXJyYXkoZGF0YSkgICYmXHJcbiAgICAgICAgICAgIC8vIGZpeCB0aGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICh0aGlzLmxlbmd0aCA9IF9nZXRMZW5ndGgoa2V5cykpO1xyXG4gICAgfVxyXG4gICAgXy5leHRlbmQoRGF0YS5wcm90b3R5cGUsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgdGhlIG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICRuYW1lc3BhY2U6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBbXSxcclxuICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBmb3IgKDsgc2VsZiAhPSB1bmRlZmluZWQ7IHNlbGYgPSBzZWxmLl91cCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fbmFtZXNwYWNlICYmXHJcbiAgICAgICAgICAgICAgICAgICAga2V5cy51bnNoaWZ0KHNlbGYuX25hbWVzcGFjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGtleSkga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXlzLmpvaW4oJy4nKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCB0aGUga2V5IG9mIGl0J3MgcGFyZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgJGtleTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fbmFtZXNwYWNlO1xyXG4gICAgICAgICAgICByZXR1cm4gK2tleSArICcnID09PSBrZXkgPyAra2V5IDoga2V5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IHRoZSBwYXJlbnQgb2YgdGhlIGRhdGFcclxuICAgICAgICAgKi9cclxuICAgICAgICAkdXA6IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICAgICAgbnVtID0gbnVtIHx8IDE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHNyYyA9IHRoaXM7IG51bS0tOykge1xyXG4gICAgICAgICAgICAgICAgc3JjID0gc3JjWydfdXAnXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3JjO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc2V0IHRoZSB2YWx1ZSBvZiB0aGUga2V5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgJHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhrZXkpLmZpbHRlcihmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrLmluZGV4T2YoJ18nKSAhPT0gMDtcclxuICAgICAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcclxuICAgICAgICAgICAgICAgICAgICBfcHJlZml4KHNlbGYsIGssIGtleVtrXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZSh0aGlzLiRuYW1lc3BhY2Uoa2V5KSwgdGhpcywgdW5kZWZpbmVkLCAxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXNba2V5XTtcclxuICAgICAgICAgICAgICAgIF9wcmVmaXgodGhpcywga2V5LCB2YWx1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBqdXN0IGJ1YmJsZVxyXG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlKHRoaXMuJG5hbWVzcGFjZShrZXkpLCB0aGlzW2tleV0sIG9sZFZhbHVlLCB1bmRlZmluZWQsIC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCB0aGUgYWN0dWFsIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgJGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzLCBrZXlzID0gdGhpcy5fa2V5cywgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmVzID0ge307XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmVzW2tleV0gPSBzZWxmW2tleV0gPT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZltrZXldIDpcclxuICAgICAgICAgICAgICAgICAgICBzZWxmW2tleV0uJGdldCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGZba2V5XS4kZ2V0KCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmW2tleV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogY2hhbmdlXHJcbiAgICAgICAgICogdHlwZSA9IDAganVzdCBjaGFuZ2VcclxuICAgICAgICAgKiB0eXBlID0gMSB0cmlnZ2VyIGNoYW5nZSAmIGRlZXBcclxuICAgICAgICAgKiB0eXBlID0gLTEganVzdCBkZWVwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgJGNoYW5nZTogZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9sZFZhbCwgcGF0Y2gsIHR5cGUpIHtcclxuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgMDtcclxuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuX3RvcDtcclxuICAgICAgICAgICAgaWYgKHRvcC4kZW1pdCkge1xyXG4gICAgICAgICAgICAgICAgfnR5cGUgJiYgdGhpcy5fdG9wLiRlbWl0KCdkYXRhOicgKyBrZXksIHZhbHVlLCBvbGRWYWwsIHBhdGNoKTtcclxuICAgICAgICAgICAgICAgIHR5cGUgJiYgdGhpcy5fdG9wLiRlbWl0KCdkZWVwOicgKyBrZXksIHZhbHVlLCBvbGRWYWwsIHBhdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gXHJcbiAgICAvKipcclxuICAgICAqIERhdGFBcnJheVxyXG4gICAgICogU29tZXRoaW5nIGp1c3QgbGlrZSBBcnJheVxyXG4gICAgICogQGNsYXNzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBEYXRhQXJyYXkob3B0aW9ucykge1xyXG4gICAgICAgIERhdGEuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIF8uZXh0ZW5kKERhdGFBcnJheS5wcm90b3R5cGUsIERhdGEucHJvdG90eXBlLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcHVzaCBkYXRhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVzaDogZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgICAgICB2YWx1ZXMgPSBfLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIF9wcmVmaXgodGhpcywgdGhpcy5sZW5ndGgsIHZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLnB1c2godGhpcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2godGhpc1t0aGlzLmxlbmd0aF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB2YWx1ZSwgb2xkVmFsdWUsIHBhdGNoXHJcbiAgICAgICAgICAgIHRoaXMuJGNoYW5nZSh0aGlzLiRuYW1lc3BhY2UoKSwgdGhpcywgbnVsbCwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAncHVzaCcsXHJcbiAgICAgICAgICAgICAgICByZXM6IHJlcyxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IHZhbHVlc1xyXG4gICAgICAgICAgICB9LCAxKTtcclxuIFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHBvcCBkYXRhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzWy0tdGhpcy5sZW5ndGhdO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpc1t0aGlzLmxlbmd0aF07XHJcbiAgICAgICAgICAgIHRoaXMuX2tleXMucG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuJGNoYW5nZSh0aGlzLiRuYW1lc3BhY2UoKSwgdGhpcywgbnVsbCwgdW5kZWZpbmVkLCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHVuc2hpZnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fa2V5cy5wdXNoKHRoaXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcclxuICAgICAgICAgICAgZm9yICh2YXIgbCA9IHRoaXMubGVuZ3RoOyBsLS07KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzW2xdID0gdGhpc1tsIC0gMV07XHJcbiAgICAgICAgICAgICAgICAvLyBmaXhlZCBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW2xdID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzW2xdLl9uYW1lc3BhY2UgPSBsICsgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9wcmVmaXgodGhpcywgMCwgdmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLiRjaGFuZ2UodGhpcy4kbmFtZXNwYWNlKCksIHRoaXMsIG51bGwsIHVuZGVmaW5lZCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc2hpZnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGlmdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlbmd0aC0tO1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpc1swXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHRoaXNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgLy8gZml4ZWQgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpc1tpXSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAodGhpc1tpXS5fbmFtZXNwYWNlID0gaSArICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9rZXlzLnBvcCgpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpc1t0aGlzLmxlbmd0aF07XHJcbiAgICAgICAgICAgIHRoaXMuJGNoYW5nZSh0aGlzLiRuYW1lc3BhY2UoKSwgdGhpcywgbnVsbCwgdW5kZWZpbmVkLCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHRvdWNoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG91Y2g6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdGhpcy4kY2hhbmdlKHRoaXMuJG5hbWVzcGFjZShrZXkpLCB0aGlzLCBudWxsLCB1bmRlZmluZWQsIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogaW5kZXhPZlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluZGV4T2Y6IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLl91cCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAraXRlbS5fbmFtZXNwYWNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzcGxpY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBzcGxpY2U6IGZ1bmN0aW9uIChpLCBsIC8qKiwgaXRlbXMgc3VwcG9ydCBsYXRlciAqKi8pIHtcclxuICAgICAgICAgICAgdmFyIHBhdGNoID0ge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnc3BsaWNlJyxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IFtpLCBsXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IGwgKyBpLCB6ID0gdGhpcy5sZW5ndGggLSBsOyBpIDwgejsgaSsrLCBqKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSB0aGlzW2sgKyBqXTtcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW2ldID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzW2ldLl9uYW1lc3BhY2UgPSBpICsgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoO2kgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoIC09IGw7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleXMuc3BsaWNlKHRoaXMubGVuZ3RoLCBsKTtcclxuICAgICAgICAgICAgdGhpcy4kY2hhbmdlKHRoaXMuJG5hbWVzcGFjZSgpLCB0aGlzLCBudWxsLCBwYXRjaCwgMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBmb3JFYWNoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24gKGZvbykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb28odGhpc1tpXSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGZpbHRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGZvbykge1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvbyhpdGVtKSkgcmVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gXHJcbiAgICAvKipcclxuICAgICAqIFNlZWRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNlZWQob3B0aW9ucykge1xyXG4gICAgICAgIERhdGEuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIF8uZXh0ZW5kKFNlZWQsIHtcclxuICAgICAgICBEYXRhOiBEYXRhLFxyXG4gICAgICAgIERhdGFBcnJheTogRGF0YUFycmF5XHJcbiAgICB9KTtcclxuICAgIF8uZXh0ZW5kKFNlZWQucHJvdG90eXBlLCBEYXRhLnByb3RvdHlwZSwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCBkYXRhIGFuZCBFbGVtZW50IHZhbHVlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtEYXRhfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbCwgZGF0YSA9IHRoaXMsIG5leHQ7XHJcbiAgICAgICAgICAgIGlmICh+a2V5LmluZGV4T2YoJy4nKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgIGZvciAobCA9IGtleXMubGVuZ3RoOyBpIDwgbCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2V5IGlzIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgra2V5ICsgJycgPT09IGtleSkga2V5ID0gK2tleTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGRhdGEgJiYgZGF0YVtrZXldICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBpcyB1bmRlZmluZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBrZXlzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpcyBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCtuZXh0ICsgJycgPT0gbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGEgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcmVmaXgoZGF0YSwga2V5LCBbXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgYSBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcmVmaXgoZGF0YSwga2V5LCB7fSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbCAmJiAoa2V5ID0ga2V5c1tpXSk7XHJcbiAgICAgICAgICAgIC8vIGlmIGRhdGEgPT09IHVuZGVmaW5lZCwganVzdCByZXR1cm5cclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBkYXRhICYmIGtleSA/IGRhdGFba2V5XSA6IGRhdGE7XHJcbiAgICAgICAgICAgIGRhdGEuJHNldChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuIFxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZWVkO1xyXG4gXHJcbiBcclxuLyoqKi8gfSxcclxuLyogNiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuIFxyXG4gICAgdmFyIERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLFxyXG4gICAgICAgIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG4gXHJcbiAgICBmdW5jdGlvbiBlbWl0KGtleSwgYXJncywgdGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gc2V0IHRoZSB0cmlnZ2VyIHRhcmdldCBpcyBwYXNzIGluIG9yIHRoaXNcclxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcztcclxuICAgICAgICB2YXIgY2JzID0gdGhpcy5fZXZlbnRzW2tleV07XHJcbiAgICAgICAgaWYgKGNicykge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID9cclxuICAgICAgICAgICAgICAgIF8uc2xpY2UuY2FsbChjYnMsIDApIDpcclxuICAgICAgICAgICAgICAgIGNicztcclxuICAgICAgICAgICAgZm9yICh2YXIgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNic1tpXS5hcHBseSh0YXJnZXQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVtaXQgcGFyZW50XHJcbiAgICAgICAgLy8gcHJldmVudCBkYXRhOiBldmVudCBhbmQgaG9vazogZXZlbnQgdHJpZ2dlclxyXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignZGF0YTonKSAmJiBrZXkuaW5kZXhPZignaG9vazonKSAmJiBrZXkuaW5kZXhPZignZGVlcDonKSAmJiB0aGlzLiRwYXJlbnQpIHtcclxuICAgICAgICAgICAgZW1pdC5jYWxsKHRoaXMuJHBhcmVudCwga2V5LCBhcmdzLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuIFxyXG4gICAgZnVuY3Rpb24gY2FsbENoYW5nZShrZXksIGFyZ3MpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHtcclxuICAgICAgICAgICAgX2V2ZW50czogdGhpcy5fd2F0Y2hlcnNcclxuICAgICAgICB9O1xyXG4gICAgICAgIGVtaXQuY2FsbChzZWxmLCBrZXksIGFyZ3MpO1xyXG4gICAgICAgIGVtaXQuY2FsbChzZWxmLCBrZXkgKyAnKipkZWVwKionLCBhcmdzKTtcclxuICAgIH1cclxuIFxyXG4gICAgZnVuY3Rpb24gY2FsbERlZXAoa2V5LCBhcmdzKSB7XHJcbiAgICAgICAgdmFyIHByb3BzLCBuQXJncyxcclxuICAgICAgICAgICAga2V5cyA9IGtleS5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgICBzZWxmID0geyBfZXZlbnRzOiB0aGlzLl93YXRjaGVycyB9O1xyXG4gXHJcbiAgICAgICAgZm9yIChrZXlzLnBvcCgpOyBrZXlzLmxlbmd0aCA+IDA7IGtleXMucG9wKCkpIHtcclxuICAgICAgICAgICAga2V5ID0ga2V5cy5qb2luKCcuJyk7XHJcbiAgICAgICAgICAgIHByb3BzID0ga2V5ICsgJyoqZGVlcCoqJztcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgdmFsdWVcclxuICAgICAgICAgICAgZW1pdC5jYWxsKHNlbGYsIHByb3BzLCBbdGhpcy5kYXRhKGtleSldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZW1pdCB2bSBpcyBjaGFuZ2VcclxuICAgICAgICBlbWl0LmNhbGwoc2VsZiwgJyoqZGVlcCoqJywgW3RoaXNdKTtcclxuICAgIH1cclxuIFxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgZW1pdDogZW1pdCxcclxuICAgICAgICBjYWxsQ2hhbmdlOiBjYWxsQ2hhbmdlLFxyXG4gICAgICAgIGNhbGxEZWVwOiBjYWxsRGVlcFxyXG4gICAgfTtcclxuIFxyXG4gXHJcbi8qKiovIH0sXHJcbi8qIDcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcbiBcclxuICAgIHZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuIFxyXG4gICAgdmFyIHN0cmF0cyA9IHt9O1xyXG4gICAgc3RyYXRzLmNyZWF0ZWQgPVxyXG4gICAgc3RyYXRzLnJlYWR5ID1cclxuICAgIHN0cmF0cy5hdHRhY2hlZCA9XHJcbiAgICBzdHJhdHMuZGV0YWNoZWQgPVxyXG4gICAgc3RyYXRzLmNvbXBpbGVkID1cclxuICAgIHN0cmF0cy5iZWZvcmVEZXN0cm95ID1cclxuICAgIHN0cmF0cy5kZXN0cm95ZWQgPVxyXG4gICAgc3RyYXRzLnBhcmFtQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsID9cclxuICAgICAgICAgICAgcGFyZW50VmFsID9cclxuICAgICAgICAgICAgICAgIHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpIDpcclxuICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGNoaWxkVmFsKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVmFsIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjaGlsZFZhbF0gOlxyXG4gICAgICAgICAgICBwYXJlbnRWYWw7XHJcbiAgICB9O1xyXG4gICAgc3RyYXRzLmRhdGEgPVxyXG4gICAgc3RyYXRzLmZpbHRlcnMgPVxyXG4gICAgc3RyYXRzLm1ldGhvZHMgPVxyXG4gICAgc3RyYXRzLmRpcmVjdGl2ZXMgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xyXG4gICAgICBpZiAoIWNoaWxkVmFsKSByZXR1cm4gcGFyZW50VmFsO1xyXG4gICAgICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsO1xyXG4gICAgICByZXR1cm4gXy5leHRlbmQoe30sIHBhcmVudFZhbCwgY2hpbGRWYWwpO1xyXG4gICAgfTtcclxuIFxyXG4gICAgdmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICBwYXJlbnRWYWwgOlxyXG4gICAgICAgICAgICBjaGlsZFZhbDtcclxuICAgIH07XHJcbiBcclxuICAgIC8qKlxyXG4gICAgICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxyXG4gICAgICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cclxuICAgICAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEFsbCBzdHJhdGVneSBmdW5jdGlvbnMgZm9sbG93IHRoZSBzYW1lIHNpZ25hdHVyZTpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHBhcmVudFZhbFxyXG4gICAgICogQHBhcmFtIHsqfSBjaGlsZFZhbFxyXG4gICAgICogQHBhcmFtIHtWdWV9IFt2bV1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQsIHZtKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fSwga2V5O1xyXG4gICAgICAgIGZvciAoa2V5IGluIHBhcmVudCkge1xyXG4gICAgICAgICAgICBtZXJnZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGtleSBpbiBjaGlsZCkge1xyXG4gICAgICAgICAgICBpZiAoIShwYXJlbnQuaGFzT3duUHJvcGVydHkoa2V5KSkpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gbWVyZ2Uoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcclxuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuIFxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgc3RyYXRzOiBzdHJhdHMsXHJcbiAgICAgICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnNcclxuICAgIH1cclxuIFxyXG4gXHJcbi8qKiovIH0sXHJcbi8qIDggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcbiBcclxuICAgIC8vIE1vZHVsZXMgbWFwXHJcbiAgICB2YXIgbW9kdWxlcyA9IHt9LFxyXG4gICAgICAgIG1lcmdlT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNykubWVyZ2VPcHRpb25zLFxyXG4gICAgICAgIGxpc3RlbmVycyA9IHt9O1xyXG4gXHJcbiAgICBmdW5jdGlvbiBfZGVmaW5lKG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAobW9kdWxlc1tuYW1lXSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBtb2R1bGUgPSBtb2R1bGVzW25hbWVdID0gdGhpcy5leHRlbmQob3B0aW9ucyB8fCB7fSk7XHJcbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcclxuICAgIH1cclxuIFxyXG4gICAgZnVuY3Rpb24gX3JlcXVpcmUobmFtZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gbW9kdWxlc1tuYW1lXSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gXHJcbiAgICBmdW5jdGlvbiBfY3JlYXRlKG8pIHtcclxuICAgICAgICBmdW5jdGlvbiBGKCkge31cclxuICAgICAgICBGLnByb3RvdHlwZSA9IG87XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGKCk7XHJcbiAgICB9XHJcbiBcclxuICAgIGZ1bmN0aW9uIF9leHRlbmQoZXh0ZW5kT3B0aW9ucykge1xyXG4gICAgICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBTdXBlciA9IHRoaXMsXHJcbiAgICAgICAgICAgIFN1YiA9IGNyZWF0ZUNsYXNzKGV4dGVuZE9wdGlvbnMubmFtZSB8fCAnUUNvbXBvbmVudCcpO1xyXG4gICAgICAgIFN1Yi5wcm90b3R5cGUgPSBfY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XHJcbiAgICAgICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcclxuICAgICAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcclxuICAgICAgICAgICAgU3VwZXIub3B0aW9ucyxcclxuICAgICAgICAgICAgZXh0ZW5kT3B0aW9uc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgU3ViWydzdXBlciddID0gU3VwZXI7XHJcbiAgICAgICAgWydleHRlbmQnLCAnZ2V0JywgJ2FsbCcsICdyZXF1aXJlJywgJ2RlZmluZSddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBTdWJba2V5XSA9IFN1cGVyW2tleV07XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gU3ViO1xyXG4gICAgfVxyXG4gXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDbGFzcyAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXHJcbiAgICAgICAgICAgICdyZXR1cm4gZnVuY3Rpb24gJyArIG5hbWUgK1xyXG4gICAgICAgICAgICAnIChvcHRpb25zKSB7IHRoaXMuX2luaXQob3B0aW9ucykgfSdcclxuICAgICAgICApKCk7XHJcbiAgICB9XHJcbiBcclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGRlZmluZVxyXG4gICAgICAgICAqIGRlZmluZSBhIGNvbXBvbmVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWZpbmU6IF9kZWZpbmUsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcmVxdWlyZVxyXG4gICAgICAgICAqIHJlcXVpcmUobmFtZSlcclxuICAgICAgICAgKiByZXF1aXJlKG5hbWVzLCBjYWxsYmFjaylcclxuICAgICAgICAgKiByZXF1aXJlIGEgY29tcG9uZW50XHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lc1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVxdWlyZTogX3JlcXVpcmUsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZXh0ZW5kXHJcbiAgICAgICAgICogZXh0ZW5kIHRoZSBjbGFzc1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXh0ZW5kOiBfZXh0ZW5kXHJcbiAgICB9O1xyXG4gXHJcbiBcclxuLyoqKi8gfSxcclxuLyogOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuIFxyXG4gICAgdmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLFxyXG4gICAgICAgIHN0cmF0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbiBcclxuICAgIHZhciBQUk9QX1JFRyA9IC9eKC4qKVxcLihbXFx3XFwtXSspJC9cclxuIFxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgY2xvYWs6IHtcclxuICAgICAgICAgICAgYmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZtID0gdGhpcy52bSxcclxuICAgICAgICAgICAgICAgICAgICBlbCA9IHRoaXMuZWw7XHJcbiBcclxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHJlYWR5XHJcbiAgICAgICAgICAgICAgICB2bS4kb25jZSgnaG9vazpyZWFkeScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBkYXRhIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgIHZtLiRvbmNlKCdkYXRhY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3EtY2xvYWsnKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG93OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzcGxheSA9IGVsLmN1cnJlbnRTdHlsZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuY3VycmVudFN0eWxlLmRpc3BsYXkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5kaXNwbGF5O1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3BsYXkgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NsYXNzJzogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWwsXHJcbiAgICAgICAgICAgICAgICBhcmcgPSB0aGlzLmFyZztcclxuICAgICAgICAgICAgaWYgKGFyZykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgP1xyXG4gICAgICAgICAgICAgICAgICAgIF8uYWRkQ2xhc3MoZWwsIGFyZykgOlxyXG4gICAgICAgICAgICAgICAgICAgIF8ucmVtb3ZlQ2xhc3MoZWwsIGFyZyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0VmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXy5yZW1vdmVDbGFzcyhlbCwgdGhpcy5sYXN0VmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF8uYWRkQ2xhc3MoZWwsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RWYWwgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xyXG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xyXG4gICAgICAgICAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciBhcmcgPSB0aGlzLmFyZyxcclxuICAgICAgICAgICAgICAgIGVsID0gdGhpcy5lbDtcclxuICAgICAgICAgICAgLy8gcHJvcGVydHlcclxuICAgICAgICAgICAgaWYgKGFyZyA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGVba10gPSB2YWx1ZVtrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGFyZywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZyBpbiBlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsW2FyZ10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGFyZywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0ZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHRleHQ7XHJcbiBcclxuICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgKHRleHQgPSAodHlwZW9mIHRoaXMuZWwudGV4dENvbnRlbnQgPT09ICdzdHJpbmcnKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmVsW3RleHRdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50b1N0cmluZygpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gdmFsdWUgJiYgdmFsdWUudG9TdHJpbmcoKSB8fCAnJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uOiB7XHJcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbSA9IHRoaXMucGFyYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVycyA9IHRoaXMuZmlsdGVycyxcclxuICAgICAgICAgICAgICAgICAgICB2bSA9IHRoaXMudm0sXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlciA9IHZtLmFwcGx5RmlsdGVycyh0aGlzLnZtW2tleV0sIGZpbHRlcnMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwYXJhbSAmJiAofnBhcmFtLmluZGV4T2YoJ3RoaXMnKSkgJiYgc2VsZi5kYXRhKCk7XHJcbiAgICAgICAgICAgICAgICBfLmFkZCh0aGlzLmVsLCB0aGlzLmFyZywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIgfHwgdHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ud2FybignWW91IG5lZWQgaW1wbGVtZW50IHRoZSAnICsga2V5ICsgJyBtZXRob2QuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0gP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcgPT09ICdlJykgYXJncy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnID09PSAndGhpcycpIGFyZ3MucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZyA9PT0gJ3RydWUnKSBhcmdzLnB1c2godHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcgPT09ICdmYWxzZScpIGFyZ3MucHVzaChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgrYXJnICsgJycgPT09IGFyZykgYXJncy5wdXNoKCthcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnLm1hdGNoKC9eKFsnXCJdKS4qXFwxJC8pKSBhcmdzLnB1c2goYXJnLnNsaWNlKDEsIC0xKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGFyZ3MucHVzaChzZWxmLmRhdGEoYXJnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGUpO1xyXG4gXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh2bSwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW9kZWw6IHtcclxuICAgICAgICAgICAgYmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSAoKHRoaXMubmFtZXNwYWNlID8gdGhpcy5uYW1lc3BhY2UgKyAnLicgOiAnJykgKyB0aGlzLnRhcmdldCkuc3BsaXQoJy4nKSxcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzLnBvcCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZSA9IGtleXMuam9pbignLicpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gdGhpcy5lbCxcclxuICAgICAgICAgICAgICAgICAgICB2bSA9IHRoaXMudm0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHZtLmRhdGEobmFtZXNwYWNlKSxcclxuICAgICAgICAgICAgICAgICAgICBjb21wb3NpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF8uYWRkKGVsLCAnaW5wdXQgcHJvcGVydHljaGFuZ2UgY2hhbmdlIGtleXByZXNzIGtleXVwJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaW5nKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS4kc2V0KGtleSwgZWwudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBfLmFkZChlbCwgJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIF8uYWRkKGVsLCAnY29tcG9zaXRpb25lbmQnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbC52YWx1ZSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHZtOiB7XHJcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0b3Agd2Fsa1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nLnN0b3AgPSB0cnVlO1xyXG4gXHJcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgdm0gPSB0aGlzLnZtLFxyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gdGhpcy5lbCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmVmID0gZWwuZ2V0QXR0cmlidXRlKCdxLXJlZicpIHx8IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIENoaWxkID0gdm0uY29uc3RydWN0b3IucmVxdWlyZShuYW1lKSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gQ2hpbGQub3B0aW9ucy5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWbTtcclxuIFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBlbDogZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBfcGFyZW50OiB2bVxyXG4gICAgICAgICAgICAgICAgfTtcclxuIFxyXG4gICAgICAgICAgICAgICAgY2hpbGRWbSA9IG5ldyBDaGlsZChvcHRpb25zKTtcclxuIFxyXG4gICAgICAgICAgICAgICAgdm0uX2NoaWxkcmVuLnB1c2goY2hpbGRWbSk7XHJcbiAgICAgICAgICAgICAgICByZWYgJiYgIWZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmcyA9IHZtLiRbcmVmXTtcclxuICAgICAgICAgICAgICAgICAgICByZWZzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5sZW5ndGggP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlZnMucHVzaChjaGlsZFZtKSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZtLiRbcmVmXSA9IFtyZWZzLCBjaGlsZFZtXSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodm0uJFtyZWZdID0gY2hpbGRWbSk7XHJcbiAgICAgICAgICAgICAgICB9KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdpZic6IHtcclxuICAgICAgICAgICAgYmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGlmIGVsIGlzIGEgdGVtcGxhdGVcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbC5wYXJlbnROb2RlKSByZXR1cm47XHJcbiBcclxuICAgICAgICAgICAgICAgIHZhciB0cGwgPSB0aGlzLmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSB0cGwucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgICAgICByZWYgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCdxLWlmJyksXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzSW5pdCA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0ID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZSxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBfLmdldChuYW1lc3BhY2UsIGtleSksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZEZpbHRlcnMgPSB0aGlzLmZpbHRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZtID0gdGhpcy52bTtcclxuIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nLnN0b3AgPSB0cnVlO1xyXG4gXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfaW5pdCh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIGV4aXN0IG5vIGJpbmRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzSW5pdCB8fCAhZXhpc3QgfHwgIXZhbHVlKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzSW5pdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdm0uX3RlbXBsYXRlQmluZCh0cGwsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gXHJcbiAgICAgICAgICAgICAgICB2bS4kd2F0Y2godGFyZ2V0LCBmdW5jdGlvbiAodmFsdWUsIG9sZFZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdm0uYXBwbHlGaWx0ZXJzKHZhbHVlLCByZWFkRmlsdGVycywgb2xkVmFsKTtcclxuIFxyXG4gICAgICAgICAgICAgICAgICAgIF9pbml0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGluaXRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGV4aXN0KSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmluZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0cGwsIHJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5iaW5kXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQocmVmLCB0cGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuIFxyXG4gICAgICAgICAgICAgICAgICAgIF9pbml0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0sIHR5cGVvZiB0aGlzLmRhdGEoa2V5KSA9PT0gJ29iamVjdCcsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbDoge1xyXG4gICAgICAgICAgICBiaW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZtLiQkW3RoaXMudGFyZ2V0XSA9IHRoaXMuZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcGVhdDogX193ZWJwYWNrX3JlcXVpcmVfXygxMClcclxuICAgIH07XHJcbiBcclxuIFxyXG4vKioqLyB9LFxyXG4vKiAxMCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuIFxyXG4gICAgdmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG4gICAgICAgIHZhciBtZXRob2RzID0ge1xyXG4gICAgICAgICAgICAnZGVmYXVsdCc6IHtcclxuICAgICAgICAgICAgICAgIC8vIGhvdyB0byBjbGVhbiB0aGUgZG9tXHJcbiAgICAgICAgICAgICAgICBjbGVhbjogZnVuY3Rpb24gKHBhcmVudE5vZGUsIHJlcGVhdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBlYXQgZWxlbWVudCBtYXkgaGFzIGJlZW4gcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUgPT09IHBhcmVudE5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy5jbGVhbkRhdGEocmVwZWF0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0OiBmdW5jdGlvbiAocGFyZW50Tm9kZSwgZnJhZ21lbnQsIHJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCByZWYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwdXNoOiB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uIChwYXJlbnROb2RlLCBmcmFnbWVudCwgcmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZnJhZ21lbnQsIHJlZik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZHA6IGZ1bmN0aW9uIChkYXRhLCBwYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRjaC5yZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNwbGljZToge1xyXG4gICAgICAgICAgICAgICAgY2xlYW46IGZ1bmN0aW9uIChwYXJlbnROb2RlLCByZXBlYXRzLCB2YWx1ZSwgd2F0Y2hlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHZhbHVlWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gdmFsdWVbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlWzJdLiRuYW1lc3BhY2UoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlcyA9IHJlcGVhdHMuc3BsaWNlKGksIGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHNwbGljZSBvbmUgdGltZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUuZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2Uod2F0Y2hlcnMsIHRhcmdldCwgaSwgbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkcDogZnVuY3Rpb24gKGRhdGEsIHBhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2guYXJncy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRjaC5hcmdzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuIFxyXG4gXHJcbiAgICBmdW5jdGlvbiBzcGxpY2Uod2F0Y2hlcnMsIHRhcmdldCwgaSwgbCkge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB0YXJnZXQubGVuZ3RoLFxyXG4gICAgICAgICAgICBzdWJLZXksXHJcbiAgICAgICAgICAgIGN1cixcclxuICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgIG5ld0tleTtcclxuICAgICAgICBPYmplY3Qua2V5cyh3YXRjaGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh+a2V5LmluZGV4T2YodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgc3ViS2V5ID0ga2V5LnN1YnN0cmluZyhsZW5ndGggKyAxKTtcclxuICAgICAgICAgICAgICAgIGN1ciA9IHN1YktleS5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1ci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9ICtjdXIuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGluZGV4IC09IGwpID49IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnVuc2hpZnQoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIudW5zaGlmdCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdLZXkgPSBjdXIuam9pbignLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXRjaGVyc1tuZXdLZXldID0gd2F0Y2hlcnNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdhdGNoZXJzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiBcclxuICAgIGV4cG9ydHMuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdHBsID0gdGhpcy5lbCxcclxuICAgICAgICAgICAgc2V0dGluZyA9IHRoaXMuc2V0dGluZyxcclxuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHRwbC5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICBrZXksIG5hbWVzcGFjZSwgdGFyZ2V0LCByZWFkRmlsdGVycywgcmVwZWF0cywgcmVmLCB2bTtcclxuICAgICAgICAvLyByZXR1cm5cclxuICAgICAgICBpZiAoIXBhcmVudE5vZGUgfHwgc2V0dGluZy5zdG9wKSByZXR1cm47XHJcbiBcclxuICAgICAgICAvLyBzdG9wIGJpbmRpbmdcclxuICAgICAgICBzZXR0aW5nLnN0b3AgPSB0cnVlO1xyXG4gXHJcbiAgICAgICAga2V5ID0gdGhpcy50YXJnZXQ7XHJcbiAgICAgICAgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2U7XHJcbiAgICAgICAgdGFyZ2V0ID0gXy5nZXQobmFtZXNwYWNlLCBrZXkpO1xyXG4gICAgICAgIHJlYWRGaWx0ZXJzID0gdGhpcy5maWx0ZXJzO1xyXG4gICAgICAgIHJlcGVhdHMgPSBbXTtcclxuICAgICAgICByZWYgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCdxLXJlcGVhdCcpO1xyXG4gICAgICAgIHZtID0gdGhpcy52bTtcclxuIFxyXG4gICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHJlZiwgdHBsKTtcclxuIFxyXG4gICAgICAgIHZtLiR3YXRjaCh0YXJnZXQsIGZ1bmN0aW9uICh2YWx1ZSwgb2xkVmFsLCBwYXRjaCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZtLmFwcGx5RmlsdGVycyh2YWx1ZSwgcmVhZEZpbHRlcnMpO1xyXG4gICAgICAgICAgICAvLyBpZiB2YWx1ZSBpcyB1bmRlZmluZWQgb3IgbnVsbCBqdXN0IHJldHVyblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gKCFyZWFkRmlsdGVycy5sZW5ndGggJiYgcGF0Y2gpID8gcGF0Y2gubWV0aG9kIDogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICAgICAgZHAgPSAobWV0aG9kc1ttZXRob2RdIHx8IHt9KS5kcCxcclxuICAgICAgICAgICAgICAgIGNsZWFuID0gKG1ldGhvZHNbbWV0aG9kXSB8fCB7fSkuY2xlYW4sXHJcbiAgICAgICAgICAgICAgICBpbnNlcnQgPSAobWV0aG9kc1ttZXRob2RdIHx8IHt9KS5pbnNlcnQ7XHJcbiBcclxuICAgICAgICAgICAgLy8gaWYgZHAgZXhpc3RzLCBwcm9jZWVzcyBkYXRhXHJcbiAgICAgICAgICAgIGRwICYmICh2YWx1ZSA9IGRwKHZhbHVlLCBwYXRjaCkpO1xyXG4gXHJcbiAgICAgICAgICAgIGlmIChjbGVhbiAmJiBjbGVhbihwYXJlbnROb2RlLCByZXBlYXRzLCB2YWx1ZSwgdm0uX3dhdGNoZXJzLCB0YXJnZXQpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuIFxyXG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXHJcbiAgICAgICAgICAgICAgICBpdGVtTm9kZTtcclxuIFxyXG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChvYmosIGkpIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1Ob2RlID0gXy5jbG9uZSh0cGwpO1xyXG4gICAgICAgICAgICAgICAgdm0uX3RlbXBsYXRlQmluZChpdGVtTm9kZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG9iaixcclxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG9iai4kbmFtZXNwYWNlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaW1tZWRpYXRlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBtdXN0IHJlZmFjdG9yXHJcbiAgICAgICAgICAgICAgICByZXBlYXRzLnB1c2goaXRlbU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoaXRlbU5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuIFxyXG4gICAgICAgICAgICBpbnNlcnQgJiYgaW5zZXJ0KHBhcmVudE5vZGUsIGZyYWdtZW50LCByZWYpO1xyXG4gICAgICAgICAgICB2bS4kZW1pdCgncmVwZWF0LXJlbmRlcicpO1xyXG4gICAgICAgIH0sIGZhbHNlLCB0cnVlKTtcclxuICAgIH1cclxuIFxyXG4gXHJcbi8qKiovIH0sXHJcbi8qIDExICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG4gXHJcbiAgICB2YXIgcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSxcclxuICAgICAgICBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuIFxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuIFxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgZGlyZWN0aXZlcyA9IHNlbGYuJG9wdGlvbnMuZGlyZWN0aXZlcyxcclxuICAgICAgICAgICAgaW5kZXggPSBvcHRpb25zLmluZGV4LFxyXG4gICAgICAgICAgICBkYXRhID0gb3B0aW9ucy5kYXRhIHx8IHNlbGYsXHJcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IG9wdGlvbnMubmFtZXNwYWNlO1xyXG4gXHJcbiAgICAgICAgXy53YWxrKFtlbF0sIGZ1bmN0aW9uIChub2RlLCByZXMsIHNldHRpbmcpIHtcclxuICAgICAgICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBvYmoubmFtZS5zdWJzdHJpbmcoMiksXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlID0gZGlyZWN0aXZlc1tuYW1lXSxcclxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9ycyA9IHBhcnNlKG9iai52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUgJiZcclxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFkRmlsdGVycyA9IHNlbGYuX21ha2VSZWFkRmlsdGVycyhkZXNjcmlwdG9yLmZpbHRlcnMsIHNlbGYuZGF0YShuYW1lc3BhY2UpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGRlc2NyaXB0b3IudGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gXy5nZXQobmFtZXNwYWNlLCBrZXkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gXy5pc09iamVjdChkaXJlY3RpdmUpID8gZGlyZWN0aXZlLnVwZGF0ZSA6IGRpcmVjdGl2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWw6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm06IHNlbGYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5kYXRhKF8uZ2V0KG5hbWVzcGFjZSwga2V5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nOiBzZXR0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBkZXNjcmlwdG9yLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyczogcmVhZEZpbHRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdGhhdC5kYXRhKGtleSk7XHJcbiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlICYmIHNlbGYuJHdhdGNoKHRhcmdldCwgZnVuY3Rpb24gKHZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmLmFwcGx5RmlsdGVycyh2YWx1ZSwgcmVhZEZpbHRlcnMsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZS5jYWxsKHRoYXQsIHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHR5cGVvZiB0bXAgPT09ICdvYmplY3QnLCBfLmFscGFjYSA/IGZhbHNlIDogdHlwZW9mIG9wdGlvbnMuaW1tZWRpYXRlID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmltbWVkaWF0ZSA6ICh0bXAgIT09IHVuZGVmaW5lZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc09iamVjdChkaXJlY3RpdmUpICYmIGRpcmVjdGl2ZS5iaW5kKSBkaXJlY3RpdmUuYmluZC5jYWxsKHRoYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiBcclxuIFxyXG4vKioqLyB9LFxyXG4vKiAxMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuIFxyXG4gICAgdmFyIGNhY2hlID0gbmV3IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxMDAwKSxcclxuICAgICAgICB0b2tlbnMgPSBbXHJcbiAgICAgICAgICAgIC8vIHNwYWNlXHJcbiAgICAgICAgICAgIFsvXiArL10sXHJcbiAgICAgICAgICAgIC8vIGFyZ1xyXG4gICAgICAgICAgICBbL14oW1xcd1xcLV0rKTovLCBmdW5jdGlvbiAoY2FwdHVyZXMsIHN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLnRva2VuLmFyZyA9IGNhcHR1cmVzWzFdO1xyXG4gICAgICAgICAgICB9XSxcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25cclxuICAgICAgICAgICAgWy9eKFtcXHddKylcXCgoLis/KVxcKS8sIGZ1bmN0aW9uIChjYXB0dXJlcywgc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMudG9rZW4udGFyZ2V0ID0gY2FwdHVyZXNbMV07XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMudG9rZW4ucGFyYW0gPSBjYXB0dXJlc1syXS5zcGxpdCgvICosICovKTtcclxuICAgICAgICAgICAgfV0sXHJcbiAgICAgICAgICAgIC8vIHRhcmdldFxyXG4gICAgICAgICAgICBbL14oW1xcd1xcLVxcLlxcJF0rKS8sIGZ1bmN0aW9uIChjYXB0dXJlcywgc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMudG9rZW4udGFyZ2V0ID0gY2FwdHVyZXNbMV07XHJcbiAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICAvLyBmaWx0ZXJcclxuICAgICAgICAgICAgWy9eKD89XFx8KS8sIGZ1bmN0aW9uIChjYXB0dXJlcywgc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMuZmlsdGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfV0sXHJcbiAgICAgICAgICAgIC8vIG5leHRcclxuICAgICAgICAgICAgWy9eLC8sIGZ1bmN0aW9uIChjYXB0dXJlcywgc3RhdHVzLCByZXMpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHN0YXR1cy50b2tlbik7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMudG9rZW4gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyczogW11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1dXHJcbiAgICAgICAgXSxcclxuICAgICAgICBmaWx0ZXJSRUcgPSAvXiguKz8pKD89LHwkKS8sXHJcbiAgICAgICAgZmlsdGVyVG9rZW5zID0gW1xyXG4gICAgICAgICAgICAvLyBzcGFjZVxyXG4gICAgICAgICAgICBbL14gKy9dLFxyXG4gICAgICAgICAgICAvLyBmaWx0ZXJcclxuICAgICAgICAgICAgWy9eXFx8ICooW1xcd1xcLVxcIV0rKS8sIGZ1bmN0aW9uIChjYXB0dXJlcywgZmlsdGVycykge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKFtjYXB0dXJlc1sxXV0pO1xyXG4gICAgICAgICAgICB9XSxcclxuICAgICAgICAgICAgLy8gc3RyaW5nXHJcbiAgICAgICAgICAgIFsvXihbJ1wiXSkoKChcXFxcWydcIl0pPyhbXlxcMV0pKikrKVxcMS8sIGZ1bmN0aW9uIChjYXB0dXJlcywgZmlsdGVycykge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyc1tmaWx0ZXJzLmxlbmd0aCAtIDFdLnB1c2goY2FwdHVyZXNbM10pO1xyXG4gICAgICAgICAgICB9XSxcclxuICAgICAgICAgICAgLy8gYXJnXHJcbiAgICAgICAgICAgIFsvXihbXFx3XFwtXFwkXSspLywgZnVuY3Rpb24gKGNhcHR1cmVzLCBmaWx0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJzW2ZpbHRlcnMubGVuZ3RoIC0gMV0ucHVzaChjYXB0dXJlc1sxXSk7XHJcbiAgICAgICAgICAgIH1dXHJcbiAgICAgICAgXTtcclxuICAgIC8qKlxyXG4gICAgICogY2xpY2s6IG9uY2xpY2sgfCBmaWx0ZXIxIHwgZmlsdGVyMlxyXG4gICAgICogY2xpY2s6IG9uY2xpY2sgLCBrZXlkb3duOiBvbmtleWRvd25cclxuICAgICAqIGNsaWNrOiBvbmNsaWNrKHRoaXMpXHJcbiAgICAgKiBjbGljazogb25jbGljayhlLCB0aGlzKVxyXG4gICAgICogdmFsdWUxIHwgZmlsdGVyMSB8IGZpbHRlcjJcclxuICAgICAqIHZhbHVlIC0gMSB8IGZpbHRlcjEgfCBmaWx0ZXIyICAgZG9uJ3Qgc3VwcG9ydFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZShzdHIpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IHN0cixcclxuICAgICAgICAgICAgaGl0ID0gY2FjaGUuZ2V0KG5hbWUpO1xyXG4gICAgICAgIGlmIChoaXQpIHJldHVybiBoaXQ7XHJcbiBcclxuICAgICAgICB2YXIgcmVzID0gW10sXHJcbiAgICAgICAgICAgIGNhcHR1cmVzLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBsID0gdG9rZW5zLmxlbmd0aCxcclxuICAgICAgICAgICAgZm9vLFxyXG4gICAgICAgICAgICAvLyBpZiBoYXMgdG9rZW4gb3Igbm90XHJcbiAgICAgICAgICAgIGhhcyA9IGZhbHNlLFxyXG4gICAgICAgICAgICBzdGF0dXMgPSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpbiBmaWx0ZXIgb3Igbm90XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgLy8ganVzdCB0b2tlbiBvYmplY3RcclxuICAgICAgICAgICAgICAgIHRva2VuOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyczogW11cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuIFxyXG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlcyA9IHRva2Vuc1tpXVswXS5leGVjKHN0cikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9vID0gdG9rZW5zW2ldWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvbyAmJiBmb28oY2FwdHVyZXMsIHN0YXR1cywgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSh0b2tlbnNbaV1bMF0sICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlcyA9IGZpbHRlclJFRy5leGVjKHN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmlsdGVyKGNhcHR1cmVzWzBdLnRyaW0oKSwgc3RhdHVzLnRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZmlsdGVyUkVHLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5maWx0ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhhcykge1xyXG4gICAgICAgICAgICAgICAgaGFzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bnRheCBlcnJvciBhdDogJyArIHN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiBcclxuICAgICAgICByZXMucHVzaChzdGF0dXMudG9rZW4pO1xyXG4gICAgICAgIGNhY2hlLnB1dChuYW1lLCByZXMpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiBcclxuICAgIGZ1bmN0aW9uIHBhcnNlRmlsdGVyKHN0ciwgdG9rZW4pIHtcclxuICAgICAgICB2YXIgaSwgbCA9IGZpbHRlclRva2Vucy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGhhcyA9IGZhbHNlO1xyXG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgXHR2YXIgY2FwdHVyZXMgPSBmaWx0ZXJUb2tlbnNbaV1bMF0uZXhlYyhzdHIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhcHR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbyA9IGZpbHRlclRva2Vuc1tpXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb28gJiYgZm9vKGNhcHR1cmVzLCB0b2tlbi5maWx0ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShmaWx0ZXJUb2tlbnNbaV1bMF0sICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGFzKSB7XHJcbiAgICAgICAgICAgICAgICBoYXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3ludGF4IGVycm9yIGF0OiAnICsgc3RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuIFxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcclxuIFxyXG4gXHJcbi8qKiovIH1cclxuLyoqKioqKi8gXSlcclxufSk7XHJcbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source-src/js/Q.js\n")},"./source-src/js/anm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar module = {\n  exports: {}\n};\nvar exports = module.exports;\nfunction init() {\n  var width,\n    height,\n    largeHeader,\n    canvas,\n    ctx,\n    circles,\n    target,\n    animateHeader = true;\n  let obj = {};\n\n  // Main\n  initHeader();\n  addListeners();\n  function initHeader() {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    target = {\n      x: 0,\n      y: height\n    };\n    largeHeader = document.getElementById('container');\n    largeHeader.style.height = height + 'px';\n    canvas = document.getElementById('anm-canvas');\n    canvas.width = width;\n    canvas.height = height;\n    ctx = canvas.getContext('2d');\n\n    // create particles\n    circles = [];\n    for (var x = 0; x < width * 0.5; x++) {\n      var c = new Circle();\n      circles.push(c);\n    }\n    animate();\n  }\n  function scrollToc() {\n    if (document.querySelector('#toc')) {\n      let titles = Array.from(document.querySelectorAll('article h1,article h2,article h3,article h4,article h5,article h6'));\n      // container\n      let scrollTop = document.querySelector('#container').scrollTop;\n      let matchTitle = titles.find(title => scrollTop <= title.offsetTop + 31);\n      matchTitle = matchTitle && matchTitle.innerText;\n\n      // \n      let tocs = Array.from(document.querySelectorAll('#toc .toc-text'));\n      let matchToc = tocs.find(toc => toc.innerText === matchTitle);\n      if (matchToc) {\n        let parentNode = matchToc.parentNode;\n        tocs.forEach(toc => toc.parentNode.classList.remove(\"toc-link-active\"));\n        parentNode.classList.add(\"toc-link-active\");\n        let currentTop = document.querySelector('.left-col').scrollTop;\n        obj.currentTop = currentTop;\n        obj.activeOffsetTop = parentNode.offsetTop;\n        if (!window.req && obj.currentTop !== obj.activeOffsetTop) {\n          requestAnimationFrame(scrollToToc.bind(obj));\n          window.req = true;\n        }\n      }\n    }\n  }\n  function scrollToToc() {\n    let currentTop = document.querySelector('.left-col').scrollTop;\n    let diff = this.activeOffsetTop - this.currentTop;\n    let targetPosition = diff > 0 ? Math.min(currentTop + diff / 10, this.activeOffsetTop) : Math.max(currentTop + diff / 10, this.activeOffsetTop);\n    // document.querySelector('.left-col').scrollTo(0, targetPosition);\n    // edge\n    document.querySelector('.left-col').scrollTop = targetPosition;\n    // \n    let maxHeight = document.querySelector('.left-col').scrollHeight - document.querySelector('.left-col').offsetHeight;\n\n    // targetPosition < maxHeight -> \n    if (targetPosition !== this.activeOffsetTop && targetPosition < maxHeight) {\n      requestAnimationFrame(scrollToToc.bind(this));\n    } else {\n      window.req = false;\n    }\n  }\n\n  // Event handling\n  function addListeners() {\n    window.addEventListener('scroll', scrollCheck);\n    document.querySelector('#container').addEventListener('scroll', scrollToc);\n    window.addEventListener('resize', resize);\n  }\n  function scrollCheck() {\n    if (document.body.scrollTop > height) animateHeader = false;else animateHeader = true;\n  }\n  function resize() {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    largeHeader.style.height = height + 'px';\n    canvas.width = width;\n    canvas.height = height;\n  }\n  function animate() {\n    if (animateHeader) {\n      ctx.clearRect(0, 0, width, height);\n      for (var i in circles) {\n        circles[i].draw();\n      }\n    }\n    requestAnimationFrame(animate);\n  }\n\n  // Canvas manipulation\n  function Circle() {\n    var _this = this;\n\n    // constructor\n    (function () {\n      _this.pos = {};\n      init();\n      //console.log(_this);\n    })();\n\n    function init() {\n      _this.pos.x = Math.random() * width;\n      _this.pos.y = height + Math.random() * 100;\n      _this.alpha = 0.1 + Math.random() * 0.3;\n      _this.scale = 0.1 + Math.random() * 0.3;\n      _this.velocity = Math.random();\n    }\n    this.draw = function () {\n      if (_this.alpha <= 0) {\n        init();\n      }\n      _this.pos.y -= _this.velocity;\n      _this.alpha -= 0.0005;\n      ctx.beginPath();\n      ctx.arc(_this.pos.x, _this.pos.y, _this.scale * 10, 0, 2 * Math.PI, false);\n      ctx.fillStyle = 'rgba(255,255,255,' + _this.alpha + ')';\n      ctx.fill();\n    };\n  }\n}\nmodule.exports = {\n  init: init\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2Utc3JjL2pzL2FubS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4by10aGVtZS1sdWNreXNoaXAvLi9zb3VyY2Utc3JjL2pzL2FubS5qcz84NmVlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGluaXQoKSB7XHJcbiAgdmFyIHdpZHRoLCBoZWlnaHQsIGxhcmdlSGVhZGVyLCBjYW52YXMsIGN0eCwgY2lyY2xlcywgdGFyZ2V0LCBhbmltYXRlSGVhZGVyID0gdHJ1ZTtcclxuICBsZXQgb2JqID0ge307XHJcblxyXG4gIC8vIE1haW5cclxuICBpbml0SGVhZGVyKCk7XHJcbiAgYWRkTGlzdGVuZXJzKCk7XHJcblxyXG4gIGZ1bmN0aW9uIGluaXRIZWFkZXIoKSB7XHJcbiAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgdGFyZ2V0ID0ge1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiBoZWlnaHRcclxuICAgIH07XHJcblxyXG4gICAgbGFyZ2VIZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJyk7XHJcbiAgICBsYXJnZUhlYWRlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xyXG5cclxuICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbm0tY2FudmFzJyk7XHJcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICAvLyBjcmVhdGUgcGFydGljbGVzXHJcbiAgICBjaXJjbGVzID0gW107XHJcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoICogMC41OyB4KyspIHtcclxuICAgICAgdmFyIGMgPSBuZXcgQ2lyY2xlKCk7XHJcbiAgICAgIGNpcmNsZXMucHVzaChjKTtcclxuICAgIH1cclxuICAgIGFuaW1hdGUoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNjcm9sbFRvYygpIHtcclxuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdG9jJykpIHtcclxuICAgICAgbGV0IHRpdGxlcyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYXJ0aWNsZSBoMSxhcnRpY2xlIGgyLGFydGljbGUgaDMsYXJ0aWNsZSBoNCxhcnRpY2xlIGg1LGFydGljbGUgaDYnKSk7XHJcbiAgICAgIC8vIOWFqOWxj+a7muWKqOadoeWHuuiHqmNvbnRhaW5lcuWFg+e0oFxyXG4gICAgICBsZXQgc2Nyb2xsVG9wID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NvbnRhaW5lcicpLnNjcm9sbFRvcDtcclxuICAgICAgbGV0IG1hdGNoVGl0bGUgPSB0aXRsZXMuZmluZCgodGl0bGUpID0+IHNjcm9sbFRvcCA8PSB0aXRsZS5vZmZzZXRUb3AgKyAzMSk7XHJcbiAgICAgIG1hdGNoVGl0bGUgPSBtYXRjaFRpdGxlICYmIG1hdGNoVGl0bGUuaW5uZXJUZXh0O1xyXG5cclxuICAgICAgLy8g5bem5L6n5a+86Iiq5qCPXHJcbiAgICAgIGxldCB0b2NzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjdG9jIC50b2MtdGV4dCcpKTtcclxuICAgICAgbGV0IG1hdGNoVG9jID0gdG9jcy5maW5kKHRvYyA9PiB0b2MuaW5uZXJUZXh0ID09PSBtYXRjaFRpdGxlKTtcclxuXHJcbiAgICAgIGlmIChtYXRjaFRvYykge1xyXG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gbWF0Y2hUb2MucGFyZW50Tm9kZVxyXG4gICAgICAgIHRvY3MuZm9yRWFjaCh0b2MgPT4gdG9jLnBhcmVudE5vZGUuY2xhc3NMaXN0LnJlbW92ZShcInRvYy1saW5rLWFjdGl2ZVwiKSlcclxuICAgICAgICBwYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoXCJ0b2MtbGluay1hY3RpdmVcIik7XHJcblxyXG4gICAgICAgIGxldCBjdXJyZW50VG9wID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxlZnQtY29sJykuc2Nyb2xsVG9wXHJcbiAgICAgICAgb2JqLmN1cnJlbnRUb3AgPSBjdXJyZW50VG9wO1xyXG4gICAgICAgIG9iai5hY3RpdmVPZmZzZXRUb3AgPSBwYXJlbnROb2RlLm9mZnNldFRvcDtcclxuXHJcbiAgICAgICAgaWYgKCF3aW5kb3cucmVxICYmIG9iai5jdXJyZW50VG9wICE9PSBvYmouYWN0aXZlT2Zmc2V0VG9wKSB7XHJcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2Nyb2xsVG9Ub2MuYmluZChvYmopKTtcclxuICAgICAgICAgIHdpbmRvdy5yZXEgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2Nyb2xsVG9Ub2MoKSB7XHJcbiAgICBsZXQgY3VycmVudFRvcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sZWZ0LWNvbCcpLnNjcm9sbFRvcDtcclxuICAgIGxldCBkaWZmID0gdGhpcy5hY3RpdmVPZmZzZXRUb3AgLSB0aGlzLmN1cnJlbnRUb3A7XHJcblxyXG4gICAgbGV0IHRhcmdldFBvc2l0aW9uID0gZGlmZiA+IDAgPyBNYXRoLm1pbihjdXJyZW50VG9wICsgZGlmZiAvIDEwLCB0aGlzLmFjdGl2ZU9mZnNldFRvcCkgOiBNYXRoLm1heChjdXJyZW50VG9wICsgZGlmZiAvIDEwLCB0aGlzLmFjdGl2ZU9mZnNldFRvcClcclxuICAgIC8vIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sZWZ0LWNvbCcpLnNjcm9sbFRvKDAsIHRhcmdldFBvc2l0aW9uKTtcclxuICAgIC8vIOWFvOWuuWVkZ2VcclxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sZWZ0LWNvbCcpLnNjcm9sbFRvcCA9IHRhcmdldFBvc2l0aW9uO1xyXG4gICAgLy8g5pyA5aSn5rua5Yqo55qE6Led56a7XHJcbiAgICBsZXQgbWF4SGVpZ2h0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxlZnQtY29sJykuc2Nyb2xsSGVpZ2h0IC0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxlZnQtY29sJykub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgIC8vIHRhcmdldFBvc2l0aW9uIDwgbWF4SGVpZ2h0IC0+IOi2hei/h+a7muWKqOi3neemu+WBnOatouWKqOeUu1xyXG4gICAgaWYgKHRhcmdldFBvc2l0aW9uICE9PSB0aGlzLmFjdGl2ZU9mZnNldFRvcCAmJiB0YXJnZXRQb3NpdGlvbiA8IG1heEhlaWdodCkge1xyXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2Nyb2xsVG9Ub2MuYmluZCh0aGlzKSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdpbmRvdy5yZXEgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEV2ZW50IGhhbmRsaW5nXHJcbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNjcm9sbENoZWNrKTtcclxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjb250YWluZXInKS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxUb2MpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzY3JvbGxDaGVjaygpIHtcclxuICAgIGlmIChkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA+IGhlaWdodCkgYW5pbWF0ZUhlYWRlciA9IGZhbHNlO1xyXG4gICAgZWxzZSBhbmltYXRlSGVhZGVyID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2l6ZSgpIHtcclxuICAgIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICBsYXJnZUhlYWRlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xyXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYW5pbWF0ZSgpIHtcclxuICAgIGlmIChhbmltYXRlSGVhZGVyKSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgIGZvciAodmFyIGkgaW4gY2lyY2xlcykge1xyXG4gICAgICAgIGNpcmNsZXNbaV0uZHJhdygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgfVxyXG5cclxuICAvLyBDYW52YXMgbWFuaXB1bGF0aW9uXHJcbiAgZnVuY3Rpb24gQ2lyY2xlKCkge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgX3RoaXMucG9zID0ge307XHJcbiAgICAgIGluaXQoKTtcclxuICAgICAgLy9jb25zb2xlLmxvZyhfdGhpcyk7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGluaXQoKSB7XHJcbiAgICAgIF90aGlzLnBvcy54ID0gTWF0aC5yYW5kb20oKSAqIHdpZHRoO1xyXG4gICAgICBfdGhpcy5wb3MueSA9IGhlaWdodCArIE1hdGgucmFuZG9tKCkgKiAxMDA7XHJcbiAgICAgIF90aGlzLmFscGhhID0gMC4xICsgTWF0aC5yYW5kb20oKSAqIDAuMztcclxuICAgICAgX3RoaXMuc2NhbGUgPSAwLjEgKyBNYXRoLnJhbmRvbSgpICogMC4zO1xyXG4gICAgICBfdGhpcy52ZWxvY2l0eSA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAoX3RoaXMuYWxwaGEgPD0gMCkge1xyXG4gICAgICAgIGluaXQoKTtcclxuICAgICAgfVxyXG4gICAgICBfdGhpcy5wb3MueSAtPSBfdGhpcy52ZWxvY2l0eTtcclxuICAgICAgX3RoaXMuYWxwaGEgLT0gMC4wMDA1O1xyXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgIGN0eC5hcmMoX3RoaXMucG9zLngsIF90aGlzLnBvcy55LCBfdGhpcy5zY2FsZSAqIDEwLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsJyArIF90aGlzLmFscGhhICsgJyknO1xyXG4gICAgICBjdHguZmlsbCgpO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGluaXQ6IGluaXRcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source-src/js/anm.js\n")},"./source-src/js/browser.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar module = {\n  exports: {}\n};\nvar exports = module.exports;\nvar browser = {\n  versions: function () {\n    var u = window.navigator.userAgent;\n    return {\n      trident: u.indexOf('Trident') > -1,\n      //IE\n      presto: u.indexOf('Presto') > -1,\n      //opera\n      webKit: u.indexOf('AppleWebKit') > -1,\n      //\n      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1,\n      //\n      mobile: !!u.match(/AppleWebKit.*Mobile.*/),\n      //\n      ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/),\n      //ios\n      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1,\n      //androiduc\n      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1,\n      //iPhoneQQ\n      iPad: u.indexOf('iPad') > -1,\n      //iPad\n      webApp: u.indexOf('Safari') == -1,\n      //web\n      weixin: u.indexOf('MicroMessenger') == -1 //\n    };\n  }()\n};\n\nmodule.exports = browser;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2Utc3JjL2pzL2Jyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4by10aGVtZS1sdWNreXNoaXAvLi9zb3VyY2Utc3JjL2pzL2Jyb3dzZXIuanM/Mzg3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYnJvd3NlciA9IHtcclxuICB2ZXJzaW9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHUgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRyaWRlbnQ6IHUuaW5kZXhPZignVHJpZGVudCcpID4gLTEsIC8vSUXlhoXmoLhcclxuICAgICAgcHJlc3RvOiB1LmluZGV4T2YoJ1ByZXN0bycpID4gLTEsIC8vb3BlcmHlhoXmoLhcclxuICAgICAgd2ViS2l0OiB1LmluZGV4T2YoJ0FwcGxlV2ViS2l0JykgPiAtMSwgLy/oi7nmnpzjgIHosLfmrYzlhoXmoLhcclxuICAgICAgZ2Vja286IHUuaW5kZXhPZignR2Vja28nKSA+IC0xICYmIHUuaW5kZXhPZignS0hUTUwnKSA9PSAtMSwgLy/ngavni5DlhoXmoLhcclxuICAgICAgbW9iaWxlOiAhIXUubWF0Y2goL0FwcGxlV2ViS2l0LipNb2JpbGUuKi8pLCAvL+aYr+WQpuS4uuenu+WKqOe7iOerr1xyXG4gICAgICBpb3M6ICEhdS5tYXRjaCgvXFwoaVteO10rOyggVTspPyBDUFUuK01hYyBPUyBYLyksIC8vaW9z57uI56uvXHJcbiAgICAgIGFuZHJvaWQ6IHUuaW5kZXhPZignQW5kcm9pZCcpID4gLTEgfHwgdS5pbmRleE9mKCdMaW51eCcpID4gLTEsIC8vYW5kcm9pZOe7iOerr+aIluiAhXVj5rWP6KeI5ZmoXHJcbiAgICAgIGlQaG9uZTogdS5pbmRleE9mKCdpUGhvbmUnKSA+IC0xIHx8IHUuaW5kZXhPZignTWFjJykgPiAtMSwgLy/mmK/lkKbkuLppUGhvbmXmiJbogIXlronljZNRUea1j+iniOWZqFxyXG4gICAgICBpUGFkOiB1LmluZGV4T2YoJ2lQYWQnKSA+IC0xLCAvL+aYr+WQpuS4umlQYWRcclxuICAgICAgd2ViQXBwOiB1LmluZGV4T2YoJ1NhZmFyaScpID09IC0xLCAvL+aYr+WQpuS4undlYuW6lOeUqOeoi+W6j++8jOayoeacieWktOmDqOS4juW6lemDqFxyXG4gICAgICB3ZWl4aW46IHUuaW5kZXhPZignTWljcm9NZXNzZW5nZXInKSA9PSAtMSAvL+aYr+WQpuS4uuW+ruS/oea1j+iniOWZqFxyXG4gICAgfTtcclxuICB9KClcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBicm93c2VyXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source-src/js/browser.js\n")},"./source-src/js/slider.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _anm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anm */ "./source-src/js/anm.js");\n/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./browser */ "./source-src/js/browser.js");\n/* harmony import */ var _Q__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Q */ "./source-src/js/Q.js");\n/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! es6-promise */ "./node_modules/es6-promise/dist/es6-promise.js");\n/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(es6_promise__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var fetch_ie8__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fetch-ie8 */ "./node_modules/fetch-ie8/fetch.js");\n/* harmony import */ var fetch_ie8__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(fetch_ie8__WEBPACK_IMPORTED_MODULE_4__);\n// \n\n// \n\n// Q \n\n// safarifetch\n\n\nvar module = {\n  exports: {}\n};\nvar exports = module.exports;\nwindow.Promise = window.Promise || es6_promise__WEBPACK_IMPORTED_MODULE_3__.Promise;\nwindow.fetch = window.fetch || fetch_ie8__WEBPACK_IMPORTED_MODULE_4__;\nlet localTagKey = "yilia-tag";\nlet localSearchKey = "yilia-search";\nconst isMobile = _browser__WEBPACK_IMPORTED_MODULE_1__["default"].versions.mobile && window.screen.width < 800;\nfunction fixzero(str) {\n  str = str + "";\n  return str.length === 1 ? "0" + str : str;\n}\nfunction setScrollZero() {\n  let $sct = document.querySelectorAll(".tools-section");\n  $sct.forEach(em => {\n    em.scrollTop = 0;\n  });\n}\nfunction init() {\n  let app = new _Q__WEBPACK_IMPORTED_MODULE_2__["default"]({\n    el: "#container",\n    data: {\n      isCtnShow: false,\n      isShow: 0,\n      innerArchive: false,\n      friends: false,\n      aboutme: false,\n      items: [],\n      jsonFail: false,\n      showTags: false,\n      search: ""\n    },\n    methods: {\n      stop: e => {\n        e.stopPropagation();\n      },\n      choseTag: (e, name) => {\n        app.$set("search", "#" + (name ? name : e.target.innerHTML));\n      },\n      clearChose: e => {\n        app.$set("search", "");\n      },\n      toggleTag: e => {\n        app.$set("showTags", !app.showTags);\n        window.localStorage && window.localStorage.setItem(localTagKey, app.showTags);\n      },\n      openSlider: (e, type) => {\n        e.stopPropagation();\n        if (!type) {\n          type = "innerArchive";\n        }\n        // innerArchive: \'\'\n        // friends: \'\'\n        // aboutme: \'\'\n        app.$set("innerArchive", false);\n        app.$set("friends", false);\n        app.$set("aboutme", false);\n        app.$set(type, true);\n        app.$set("isShow", true);\n        app.$set("isCtnShow", true);\n        setScrollZero();\n      }\n    },\n    filters: {\n      isFalse: val => {\n        return val === false;\n      },\n      isEmptyStr: str => {\n        return str === "";\n      },\n      isNotEmptyStr: str => {\n        return str !== "";\n      },\n      urlformat: str => {\n        if (window.yiliaConfig && window.yiliaConfig.root) {\n          return window.yiliaConfig.root + str;\n        }\n        return "/" + str;\n      },\n      tagformat: str => {\n        return "#" + str;\n      },\n      dateformat: str => {\n        let d = new Date(str);\n        return d.getFullYear() + "-" + fixzero(d.getMonth() + 1) + "-" + fixzero(d.getDate());\n      }\n    },\n    ready: () => {}\n  });\n  function handleSearch(val) {\n    val = (val || "").toLowerCase();\n    let type = "title";\n    if (val.indexOf("#") === 0) {\n      val = val.substr(1, val.length);\n      type = "tag";\n    }\n    !app.originItems && app.$set("originItems", app.items);\n    let items = app.originItems;\n    items.forEach(item => {\n      let matchTitle = false;\n      if (item.title.toLowerCase().indexOf(val) > -1) {\n        matchTitle = item.title;\n      }\n      let reg = new RegExp(`(.{0,20})(${val})(.{0,20})`, "i");\n      let textArr = item.text.match(reg);\n      let titleArr = item.title.match(reg);\n      let regArr = titleArr || textArr;\n      item.titleArr = titleArr;\n      let matchContent = {};\n      if (regArr) {\n        // \n        matchContent = {\n          pre: regArr[1],\n          val: regArr[2],\n          next: regArr[3]\n        };\n      }\n      let matchTags = false;\n      item.tags.forEach(tag => {\n        if (tag.name.toLowerCase().indexOf(val) > -1) {\n          matchTags = true;\n        }\n      });\n      if (type === "title" && (matchTitle || matchContent.val) || type === "tag" && matchTags) {\n        item.matchTitle = matchTitle;\n        item.matchContent = matchContent;\n        item.isShow = true;\n      } else {\n        item.isShow = false;\n      }\n    });\n    items = Array.from(items);\n    if (val) {\n      items && items.sort((a, b) => {\n        if (a.titleArr && !b.titleArr) {\n          return -1;\n        } else {\n          return 1;\n        }\n      });\n    }\n    app.$set("items", items);\n  }\n\n  // \n  function debounce(func, wait) {\n    var timer = null;\n    return function () {\n      var self = this,\n        args = arguments;\n      if (timer) {\n        clearTimeout(timer);\n      }\n      timer = setTimeout(function () {\n        timer = null;\n        return typeof func === "function" && func.apply(self, args);\n      }, wait);\n    };\n  }\n  let debounceHandleSearch = debounce(handleSearch, 200);\n  app.$watch("search", function (val, oldVal) {\n    window.localStorage && window.localStorage.setItem(localSearchKey, val);\n    debounceHandleSearch(val);\n  });\n  const query = new AV.Query("TestObject");\n  query.limit(1000);\n  query.find().then(TestObject => {\n    let data = TestObject.map(item => item.attributes);\n    data.forEach(em => {\n      em.isShow = true;\n    });\n    app.$set("items", data);\n\n    // \n    let searchWording = window.localStorage && window.localStorage.getItem(localSearchKey) || "";\n    app.$set("search", searchWording);\n    searchWording !== "" && handleSearch(searchWording);\n  });\n\n  // \n  document.querySelector("#container").onclick = e => {\n    if (app.isShow) {\n      app.$set("isShow", false);\n      setTimeout(() => {\n        app.$set("isCtnShow", false);\n      }, 300);\n    }\n  };\n\n  // tag /\n  let localTag = false;\n  if (window.localStorage) {\n    localTag = window.localStorage.getItem(localTagKey);\n  }\n  let isTagOn = "false";\n  if (localTag === null) {\n    isTagOn = window.yiliaConfig && window.yiliaConfig.showTags ? "true" : "false";\n  } else {\n    isTagOn = window.localStorage && window.localStorage.getItem(localTagKey) || "false";\n  }\n  app.$set("showTags", JSON.parse(isTagOn));\n\n  // \n  // \n  let $tags = document.querySelectorAll(".tagcloud a.js-tag");\n  for (var i = 0, len = $tags.length; i < len; i++) {\n    let $em = $tags[i];\n    $em.setAttribute("href", "javascript:void(0)");\n    $em.onclick = e => {\n      e.stopPropagation();\n      app.$set("innerArchive", true);\n      app.$set("friends", false);\n      app.$set("aboutme", false);\n      app.$set("isShow", true);\n      app.$set("isCtnShow", true);\n      app.$set("search", "#" + $em.innerHTML);\n      setScrollZero();\n      return false;\n    };\n  }\n}\n\n// DOMContentLoadedinit\nif (document.querySelector("#container")) {\n  init();\n  if (!isMobile) {\n    _anm__WEBPACK_IMPORTED_MODULE_0__["default"].init();\n  }\n}\n\n// dom\ndocument.addEventListener("DOMContentLoaded", function () {\n  init();\n  if (!isMobile) {\n    _anm__WEBPACK_IMPORTED_MODULE_0__["default"].init();\n  }\n});\nmodule.exports = {};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2Utc3JjL2pzL3NsaWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4by10aGVtZS1sdWNreXNoaXAvLi9zb3VyY2Utc3JjL2pzL3NsaWRlci5qcz9kNzFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIOWKqOeUu1xuaW1wb3J0IEFubSBmcm9tIFwiLi9hbm1cIjtcbi8vIOa1j+iniOWZqOWIpOaWrVxuaW1wb3J0IEJyb3dzZXIgZnJvbSBcIi4vYnJvd3NlclwiO1xuLy8gUSDln7rnoYDlupNcbmltcG9ydCBRIGZyb20gXCIuL1FcIjtcbi8vIOelnueJueS5iHNhZmFyaeS4jeaUr+aMgWZldGNoXG5pbXBvcnQgKiBhcyBwcm9taXNlIGZyb20gXCJlczYtcHJvbWlzZVwiO1xuaW1wb3J0ICogYXMgZmV0Y2ggZnJvbSBcImZldGNoLWllOFwiO1xuXG53aW5kb3cuUHJvbWlzZSA9IHdpbmRvdy5Qcm9taXNlIHx8IHByb21pc2UuUHJvbWlzZTtcbndpbmRvdy5mZXRjaCA9IHdpbmRvdy5mZXRjaCB8fCBmZXRjaDtcblxubGV0IGxvY2FsVGFnS2V5ID0gXCJ5aWxpYS10YWdcIjtcbmxldCBsb2NhbFNlYXJjaEtleSA9IFwieWlsaWEtc2VhcmNoXCI7XG5jb25zdCBpc01vYmlsZSA9IEJyb3dzZXIudmVyc2lvbnMubW9iaWxlICYmIHdpbmRvdy5zY3JlZW4ud2lkdGggPCA4MDA7XG5cbmZ1bmN0aW9uIGZpeHplcm8oc3RyKSB7XG4gIHN0ciA9IHN0ciArIFwiXCI7XG4gIHJldHVybiBzdHIubGVuZ3RoID09PSAxID8gXCIwXCIgKyBzdHIgOiBzdHI7XG59XG5cbmZ1bmN0aW9uIHNldFNjcm9sbFplcm8oKSB7XG4gIGxldCAkc2N0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50b29scy1zZWN0aW9uXCIpO1xuICAkc2N0LmZvckVhY2goKGVtKSA9PiB7XG4gICAgZW0uc2Nyb2xsVG9wID0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGxldCBhcHAgPSBuZXcgUSh7XG4gICAgZWw6IFwiI2NvbnRhaW5lclwiLFxuICAgIGRhdGE6IHtcbiAgICAgIGlzQ3RuU2hvdzogZmFsc2UsXG4gICAgICBpc1Nob3c6IDAsXG4gICAgICBpbm5lckFyY2hpdmU6IGZhbHNlLFxuICAgICAgZnJpZW5kczogZmFsc2UsXG4gICAgICBhYm91dG1lOiBmYWxzZSxcbiAgICAgIGl0ZW1zOiBbXSxcbiAgICAgIGpzb25GYWlsOiBmYWxzZSxcbiAgICAgIHNob3dUYWdzOiBmYWxzZSxcbiAgICAgIHNlYXJjaDogXCJcIixcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHN0b3A6IChlKSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LFxuICAgICAgY2hvc2VUYWc6IChlLCBuYW1lKSA9PiB7XG4gICAgICAgIGFwcC4kc2V0KFwic2VhcmNoXCIsIFwiI1wiICsgKG5hbWUgPyBuYW1lIDogZS50YXJnZXQuaW5uZXJIVE1MKSk7XG4gICAgICB9LFxuICAgICAgY2xlYXJDaG9zZTogKGUpID0+IHtcbiAgICAgICAgYXBwLiRzZXQoXCJzZWFyY2hcIiwgXCJcIik7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlVGFnOiAoZSkgPT4ge1xuICAgICAgICBhcHAuJHNldChcInNob3dUYWdzXCIsICFhcHAuc2hvd1RhZ3MpO1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlICYmXG4gICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsVGFnS2V5LCBhcHAuc2hvd1RhZ3MpO1xuICAgICAgfSxcbiAgICAgIG9wZW5TbGlkZXI6IChlLCB0eXBlKSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHR5cGUgPSBcImlubmVyQXJjaGl2ZVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlubmVyQXJjaGl2ZTogJ+aJgOacieaWh+eroCdcbiAgICAgICAgLy8gZnJpZW5kczogJ+WPi+aDhemTvuaOpSdcbiAgICAgICAgLy8gYWJvdXRtZTogJ+WFs+S6juaIkSdcbiAgICAgICAgYXBwLiRzZXQoXCJpbm5lckFyY2hpdmVcIiwgZmFsc2UpO1xuICAgICAgICBhcHAuJHNldChcImZyaWVuZHNcIiwgZmFsc2UpO1xuICAgICAgICBhcHAuJHNldChcImFib3V0bWVcIiwgZmFsc2UpO1xuICAgICAgICBhcHAuJHNldCh0eXBlLCB0cnVlKTtcbiAgICAgICAgYXBwLiRzZXQoXCJpc1Nob3dcIiwgdHJ1ZSk7XG4gICAgICAgIGFwcC4kc2V0KFwiaXNDdG5TaG93XCIsIHRydWUpO1xuICAgICAgICBzZXRTY3JvbGxaZXJvKCk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgZmlsdGVyczoge1xuICAgICAgaXNGYWxzZTogKHZhbCkgPT4ge1xuICAgICAgICByZXR1cm4gdmFsID09PSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBpc0VtcHR5U3RyOiAoc3RyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdHIgPT09IFwiXCI7XG4gICAgICB9LFxuICAgICAgaXNOb3RFbXB0eVN0cjogKHN0cikgPT4ge1xuICAgICAgICByZXR1cm4gc3RyICE9PSBcIlwiO1xuICAgICAgfSxcbiAgICAgIHVybGZvcm1hdDogKHN0cikgPT4ge1xuICAgICAgICBpZiAod2luZG93LnlpbGlhQ29uZmlnICYmIHdpbmRvdy55aWxpYUNvbmZpZy5yb290KSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy55aWxpYUNvbmZpZy5yb290ICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIi9cIiArIHN0cjtcbiAgICAgIH0sXG4gICAgICB0YWdmb3JtYXQ6IChzdHIpID0+IHtcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgc3RyO1xuICAgICAgfSxcbiAgICAgIGRhdGVmb3JtYXQ6IChzdHIpID0+IHtcbiAgICAgICAgbGV0IGQgPSBuZXcgRGF0ZShzdHIpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGQuZ2V0RnVsbFllYXIoKSArXG4gICAgICAgICAgXCItXCIgK1xuICAgICAgICAgIGZpeHplcm8oZC5nZXRNb250aCgpICsgMSkgK1xuICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICBmaXh6ZXJvKGQuZ2V0RGF0ZSgpKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICB9LFxuICAgIHJlYWR5OiAoKSA9PiB7fSxcbiAgfSk7XG5cbiAgZnVuY3Rpb24gaGFuZGxlU2VhcmNoKHZhbCkge1xuICAgIHZhbCA9ICh2YWwgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgdHlwZSA9IFwidGl0bGVcIjtcbiAgICBpZiAodmFsLmluZGV4T2YoXCIjXCIpID09PSAwKSB7XG4gICAgICB2YWwgPSB2YWwuc3Vic3RyKDEsIHZhbC5sZW5ndGgpO1xuICAgICAgdHlwZSA9IFwidGFnXCI7XG4gICAgfVxuXG4gICAgIWFwcC5vcmlnaW5JdGVtcyAmJiBhcHAuJHNldChcIm9yaWdpbkl0ZW1zXCIsIGFwcC5pdGVtcyk7XG4gICAgbGV0IGl0ZW1zID0gYXBwLm9yaWdpbkl0ZW1zO1xuXG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgbGV0IG1hdGNoVGl0bGUgPSBmYWxzZTtcbiAgICAgIGlmIChpdGVtLnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWwpID4gLTEpIHtcbiAgICAgICAgbWF0Y2hUaXRsZSA9IGl0ZW0udGl0bGU7XG4gICAgICB9XG5cbiAgICAgIGxldCByZWcgPSBuZXcgUmVnRXhwKGAoLnswLDIwfSkoJHt2YWx9KSguezAsMjB9KWAsIFwiaVwiKTtcbiAgICAgIGxldCB0ZXh0QXJyID0gaXRlbS50ZXh0Lm1hdGNoKHJlZyk7XG4gICAgICBsZXQgdGl0bGVBcnIgPSBpdGVtLnRpdGxlLm1hdGNoKHJlZyk7XG4gICAgICBsZXQgcmVnQXJyID0gdGl0bGVBcnIgfHwgdGV4dEFycjtcbiAgICAgIGl0ZW0udGl0bGVBcnIgPSB0aXRsZUFycjtcbiAgICAgIGxldCBtYXRjaENvbnRlbnQgPSB7fTtcbiAgICAgIGlmIChyZWdBcnIpIHtcbiAgICAgICAgLy8g5pCc57Si5a+55bqU5YaF5a655ZKM5YaF5a6555qE6L6555WMXG4gICAgICAgIG1hdGNoQ29udGVudCA9IHtcbiAgICAgICAgICBwcmU6IHJlZ0FyclsxXSxcbiAgICAgICAgICB2YWw6IHJlZ0FyclsyXSxcbiAgICAgICAgICBuZXh0OiByZWdBcnJbM10sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGxldCBtYXRjaFRhZ3MgPSBmYWxzZTtcbiAgICAgIGl0ZW0udGFncy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgICAgaWYgKHRhZy5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWwpID4gLTEpIHtcbiAgICAgICAgICBtYXRjaFRhZ3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKFxuICAgICAgICAodHlwZSA9PT0gXCJ0aXRsZVwiICYmIChtYXRjaFRpdGxlIHx8IG1hdGNoQ29udGVudC52YWwpKSB8fFxuICAgICAgICAodHlwZSA9PT0gXCJ0YWdcIiAmJiBtYXRjaFRhZ3MpXG4gICAgICApIHtcbiAgICAgICAgaXRlbS5tYXRjaFRpdGxlID0gbWF0Y2hUaXRsZTtcbiAgICAgICAgaXRlbS5tYXRjaENvbnRlbnQgPSBtYXRjaENvbnRlbnQ7XG4gICAgICAgIGl0ZW0uaXNTaG93ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW0uaXNTaG93ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaXRlbXMgPSBBcnJheS5mcm9tKGl0ZW1zKTtcbiAgICBpZiAodmFsKSB7XG4gICAgICBpdGVtcyAmJlxuICAgICAgICBpdGVtcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgaWYgKGEudGl0bGVBcnIgJiYgIWIudGl0bGVBcnIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXBwLiRzZXQoXCJpdGVtc1wiLCBpdGVtcyk7XG4gIH1cblxuICAvLyDpmLLmipZcbiAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCkge1xuICAgIHZhciB0aW1lciA9IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmICh0aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09IFwiZnVuY3Rpb25cIiAmJiBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfSwgd2FpdCk7XG4gICAgfTtcbiAgfVxuXG4gIGxldCBkZWJvdW5jZUhhbmRsZVNlYXJjaCA9IGRlYm91bmNlKGhhbmRsZVNlYXJjaCwgMjAwKTtcblxuICBhcHAuJHdhdGNoKFwic2VhcmNoXCIsIGZ1bmN0aW9uICh2YWwsIG9sZFZhbCkge1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UgJiYgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsU2VhcmNoS2V5LCB2YWwpO1xuICAgIGRlYm91bmNlSGFuZGxlU2VhcmNoKHZhbCk7XG4gIH0pO1xuXG4gIGNvbnN0IHF1ZXJ5ID0gbmV3IEFWLlF1ZXJ5KFwiVGVzdE9iamVjdFwiKTtcbiAgcXVlcnkubGltaXQoMTAwMCk7XG4gIHF1ZXJ5LmZpbmQoKS50aGVuKChUZXN0T2JqZWN0KSA9PiB7XG4gICAgbGV0IGRhdGEgPSBUZXN0T2JqZWN0Lm1hcCgoaXRlbSkgPT4gaXRlbS5hdHRyaWJ1dGVzKTtcblxuICAgIGRhdGEuZm9yRWFjaCgoZW0pID0+IHtcbiAgICAgIGVtLmlzU2hvdyA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBhcHAuJHNldChcIml0ZW1zXCIsIGRhdGEpO1xuXG4gICAgLy8g5pCc57Si5Y6G5Y+y6K6w5b2VXG4gICAgbGV0IHNlYXJjaFdvcmRpbmcgPVxuICAgICAgKHdpbmRvdy5sb2NhbFN0b3JhZ2UgJiYgd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGxvY2FsU2VhcmNoS2V5KSkgfHxcbiAgICAgIFwiXCI7XG4gICAgYXBwLiRzZXQoXCJzZWFyY2hcIiwgc2VhcmNoV29yZGluZyk7XG4gICAgc2VhcmNoV29yZGluZyAhPT0gXCJcIiAmJiBoYW5kbGVTZWFyY2goc2VhcmNoV29yZGluZyk7XG4gIH0pO1xuXG4gIC8vIOmakOiXj1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2NvbnRhaW5lclwiKS5vbmNsaWNrID0gKGUpID0+IHtcbiAgICBpZiAoYXBwLmlzU2hvdykge1xuICAgICAgYXBwLiRzZXQoXCJpc1Nob3dcIiwgZmFsc2UpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGFwcC4kc2V0KFwiaXNDdG5TaG93XCIsIGZhbHNlKTtcbiAgICAgIH0sIDMwMCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIHRhZyDmmL7npLov6ZqQ6JePXG4gIGxldCBsb2NhbFRhZyA9IGZhbHNlO1xuICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgIGxvY2FsVGFnID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGxvY2FsVGFnS2V5KTtcbiAgfVxuICBsZXQgaXNUYWdPbiA9IFwiZmFsc2VcIjtcbiAgaWYgKGxvY2FsVGFnID09PSBudWxsKSB7XG4gICAgaXNUYWdPbiA9XG4gICAgICB3aW5kb3cueWlsaWFDb25maWcgJiYgd2luZG93LnlpbGlhQ29uZmlnLnNob3dUYWdzID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gIH0gZWxzZSB7XG4gICAgaXNUYWdPbiA9XG4gICAgICAod2luZG93LmxvY2FsU3RvcmFnZSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0obG9jYWxUYWdLZXkpKSB8fFxuICAgICAgXCJmYWxzZVwiO1xuICB9XG4gIGFwcC4kc2V0KFwic2hvd1RhZ3NcIiwgSlNPTi5wYXJzZShpc1RhZ09uKSk7XG5cbiAgLy8g5YW25LuW5qCH562+54K55Ye7XG4gIC8vIOagh+etvlxuICBsZXQgJHRhZ3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhZ2Nsb3VkIGEuanMtdGFnXCIpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHRhZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgJGVtID0gJHRhZ3NbaV07XG4gICAgJGVtLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgXCJqYXZhc2NyaXB0OnZvaWQoMClcIik7XG4gICAgJGVtLm9uY2xpY2sgPSAoZSkgPT4ge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGFwcC4kc2V0KFwiaW5uZXJBcmNoaXZlXCIsIHRydWUpO1xuICAgICAgYXBwLiRzZXQoXCJmcmllbmRzXCIsIGZhbHNlKTtcbiAgICAgIGFwcC4kc2V0KFwiYWJvdXRtZVwiLCBmYWxzZSk7XG4gICAgICBhcHAuJHNldChcImlzU2hvd1wiLCB0cnVlKTtcbiAgICAgIGFwcC4kc2V0KFwiaXNDdG5TaG93XCIsIHRydWUpO1xuICAgICAgYXBwLiRzZXQoXCJzZWFyY2hcIiwgXCIjXCIgKyAkZW0uaW5uZXJIVE1MKTtcbiAgICAgIHNldFNjcm9sbFplcm8oKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG59XG5cbi8vIOmYsuatokRPTUNvbnRlbnRMb2FkZWTml7bpl7TliqDovb3lrozmiJDvvIzov5jmnKrmiafooYxpbml0XG5pZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjb250YWluZXJcIikpIHtcbiAgaW5pdCgpO1xuICBpZiAoIWlzTW9iaWxlKSB7XG4gICAgQW5tLmluaXQoKTtcbiAgfVxufVxuXG4vLyDnrYnlvoVkb23nlJ/miJBcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgaW5pdCgpO1xuICBpZiAoIWlzTW9iaWxlKSB7XG4gICAgQW5tLmluaXQoKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source-src/js/slider.js\n')},"./node_modules/es6-promise/dist/es6-promise.js":function(module,__unused_webpack_exports,__webpack_require__){eval("/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\t0;\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && \"function\" === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    var then$$1 = void 0;\n    try {\n      then$$1 = value.then;\n    } catch (error) {\n      reject(promise, error);\n      return;\n    }\n    handleMaybeThenable(promise, value, then$$1);\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = true;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n    } catch (e) {\n      succeeded = false;\n      error = e;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (succeeded === false) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = void 0;\n      var error = void 0;\n      var didError = false;\n      try {\n        _then = entry.then;\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        if (didError) {\n          reject(promise, error);\n        } else {\n          handleMaybeThenable(promise, entry, _then);\n        }\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof __webpack_require__.g !== 'undefined') {\n    local = __webpack_require__.g;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWx1Y2t5c2hpcC8uL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzPzEzNjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N0ZWZhbnBlbm5lci9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICB2NC4yLjgrMWU2OGRjZTZcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG5cbnZhciBfaXNBcnJheSA9IHZvaWQgMDtcbmlmIChBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB2b2lkIDA7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB2b2lkIDA7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdmVydHggPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpLnJlcXVpcmUoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHZvaWQgMDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSBhdHRlbXB0VmVydHgoKTtcbn0gZWxzZSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKGNoaWxkW1BST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcbiAgICBtYWtlUHJvbWlzZShjaGlsZCk7XG4gIH1cblxuICB2YXIgX3N0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuXG4gIGlmIChfc3RhdGUpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbX3N0YXRlIC0gMV07XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuICBwYXNzZWQgYHZhbHVlYC4gSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlc29sdmUoMSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVzb2x2ZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICBgdmFsdWVgXG4qL1xuZnVuY3Rpb24gcmVzb2x2ZSQxKG9iamVjdCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgUEVORElORyA9IHZvaWQgMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcblxuZnVuY3Rpb24gc2VsZkZ1bGZpbGxtZW50KCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG59XG5cbmZ1bmN0aW9uIGNhbm5vdFJldHVybk93bigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbiQkMSkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgc2VsZkZ1bGZpbGxtZW50KCkpO1xuICB9IGVsc2UgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIHRoZW4kJDEgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHRoZW4kJDEgPSB2YWx1ZS50aGVuO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCB0aGVuJCQxKTtcbiAgfSBlbHNlIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gIH1cblxuICBwdWJsaXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEO1xuICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgYXNhcChwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICB2YXIgbGVuZ3RoID0gX3N1YnNjcmliZXJzLmxlbmd0aDtcblxuXG4gIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgX3N1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgUkVKRUNURURdID0gb25SZWplY3Rpb247XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwYXJlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSkge1xuICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gdm9pZCAwLFxuICAgICAgY2FsbGJhY2sgPSB2b2lkIDAsXG4gICAgICBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9XG4gIH1cblxuICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgdmFsdWUgPSB2b2lkIDAsXG4gICAgICBlcnJvciA9IHZvaWQgMCxcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZGV0YWlsO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHN1Y2NlZWRlZCA9PT0gZmFsc2UpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG59XG5cbnZhciBFbnVtZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cbiAgICBpZiAoIXRoaXMucHJvbWlzZVtQUk9NSVNFX0lEXSkge1xuICAgICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICAgIHRoaXMuX2VudW1lcmF0ZShpbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3QodGhpcy5wcm9taXNlLCB2YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgfVxuICB9XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uIF9lbnVtZXJhdGUoaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgdGhpcy5fc3RhdGUgPT09IFBFTkRJTkcgJiYgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gX2VhY2hFbnRyeShlbnRyeSwgaSkge1xuICAgIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgICB2YXIgcmVzb2x2ZSQkMSA9IGMucmVzb2x2ZTtcblxuXG4gICAgaWYgKHJlc29sdmUkJDEgPT09IHJlc29sdmUkMSkge1xuICAgICAgdmFyIF90aGVuID0gdm9pZCAwO1xuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBfdGhlbiA9IGVudHJ5LnRoZW47XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgICAgfSBlbHNlIGlmIChjID09PSBQcm9taXNlJDEpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgYyhub29wKTtcbiAgICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgICB9KSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiBfc2V0dGxlZEF0KHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG5cbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcbiAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRW51bWVyYXRvcjtcbn0oKTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5cbnZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gIH0pO1xuICBgYGBcbiAgIENoYWluaW5nXG4gIC0tLS0tLS0tXG4gICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gIH0pO1xuICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgfSk7XG4gIGBgYFxuICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgQXNzaW1pbGF0aW9uXG4gIC0tLS0tLS0tLS0tLVxuICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcbiAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IHJlc3VsdDtcbiAgIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBmYWlsdXJlXG4gIH0pO1xuICBgYGBcbiAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IGF1dGhvciwgYm9va3M7XG4gICB0cnkge1xuICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gICB9XG4gICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICAgfVxuICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRBdXRob3IoKS5cbiAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgIC8vIGZvdW5kIGJvb2tzXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG4gIC8qKlxuICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cbiAgLy8gc3luY2hyb25vdXNcbiAgdHJ5IHtcbiAgZmluZEF1dGhvcigpO1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG4gIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICB0cnkvY2F0Y2gvZmluYWxseSBiZWhhdmVzXG4gIFxuICAgIFN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpIHtcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAvLyBkb2Vzbid0IGFmZmVjdCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAvLyBhdXRob3Igd2FzIGVpdGhlciBmb3VuZCwgb3Igbm90XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgZmluYWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihjYWxsYmFjaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIHJldHVybiBQcm9taXNlO1xufSgpO1xuXG5Qcm9taXNlJDEucHJvdG90eXBlLnRoZW4gPSB0aGVuO1xuUHJvbWlzZSQxLmFsbCA9IGFsbDtcblByb21pc2UkMS5yYWNlID0gcmFjZTtcblByb21pc2UkMS5yZXNvbHZlID0gcmVzb2x2ZSQxO1xuUHJvbWlzZSQxLnJlamVjdCA9IHJlamVjdCQxO1xuUHJvbWlzZSQxLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlJDEuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZSQxLl9hc2FwID0gYXNhcDtcblxuLypnbG9iYWwgc2VsZiovXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgdmFyIGxvY2FsID0gdm9pZCAwO1xuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gIGlmIChQKSB7XG4gICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgIH1cblxuICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2UkMTtcbn1cblxuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZSQxLnBvbHlmaWxsID0gcG9seWZpbGw7XG5Qcm9taXNlJDEuUHJvbWlzZSA9IFByb21pc2UkMTtcblxucmV0dXJuIFByb21pc2UkMTtcblxufSkpKTtcblxuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzNi1wcm9taXNlLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/es6-promise/dist/es6-promise.js\n")},"./node_modules/fetch-ie8/fetch.js":function(module){eval("(function(self) {\n  'use strict';\n\n  // if __disableNativeFetch is set to true, the it will always polyfill fetch\n  // with Ajax.\n  if (!self.__disableNativeFetch && self.fetch) {\n    return\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob, options) {\n    var reader = new FileReader()\n    var contentType = options.headers.map['content-type'] ? options.headers.map['content-type'].toString() : ''\n    var regex = /charset\\=[0-9a-zA-Z\\-\\_]*;?/\n    var _charset = blob.type.match(regex) || contentType.match(regex)\n    var args = [blob]\n\n    if(_charset) {\n      args.push(_charset[0].replace(/^charset\\=/, '').replace(/;$/, ''))\n    }\n\n    reader.readAsText.apply(reader, args)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n\n    this._initBody = function(body, options) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n        this._options = options\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob, this._options)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body, options)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this._initBody(bodyInit, options)\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return;\n      }\n\n      var __onLoadHandled = false;\n\n      function onload() {\n        if (xhr.readyState !== 4) {\n          return\n        }\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          if (__onLoadHandled) { return; } else { __onLoadHandled = true; }\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n\n        if (__onLoadHandled) { return; } else { __onLoadHandled = true; }\n        resolve(new Response(body, options))\n      }\n      xhr.onreadystatechange = onload;\n      xhr.onload = onload;\n      xhr.onerror = function() {\n        if (__onLoadHandled) { return; } else { __onLoadHandled = true; }\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      // `withCredentials` should be setted after calling `.open` in IE10\n      // http://stackoverflow.com/a/19667959/1219343\n      try {\n        if (request.credentials === 'include') {\n          if ('withCredentials' in xhr) {\n            xhr.withCredentials = true;\n          } else {\n            console && console.warn && console.warn('withCredentials is not supported, you can ignore this warning');\n          }\n        }\n      } catch (e) {\n        console && console.warn && console.warn('set withCredentials error:' + e);\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n\n  // Support CommonJS\n  if ( true && module.exports) {\n    module.exports = self.fetch;\n  }\n})(typeof self !== 'undefined' ? self : this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmV0Y2gtaWU4L2ZldGNoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4by10aGVtZS1sdWNreXNoaXAvLi9ub2RlX21vZHVsZXMvZmV0Y2gtaWU4L2ZldGNoLmpzP2U5MDEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGlmIF9fZGlzYWJsZU5hdGl2ZUZldGNoIGlzIHNldCB0byB0cnVlLCB0aGUgaXQgd2lsbCBhbHdheXMgcG9seWZpbGwgZmV0Y2hcbiAgLy8gd2l0aCBBamF4LlxuICBpZiAoIXNlbGYuX19kaXNhYmxlTmF0aXZlRmV0Y2ggJiYgc2VsZi5mZXRjaCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5cXF5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICB9LCB0aGlzKVxuXG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgdmFyIGxpc3QgPSB0aGlzLm1hcFtuYW1lXVxuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IFtdXG4gICAgICB0aGlzLm1hcFtuYW1lXSA9IGxpc3RcbiAgICB9XG4gICAgbGlzdC5wdXNoKHZhbHVlKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICAgIHJldHVybiB2YWx1ZXMgPyB2YWx1ZXNbMF0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldIHx8IFtdXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gW25vcm1hbGl6ZVZhbHVlKHZhbHVlKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMubWFwKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMubWFwW25hbWVdLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcylcbiAgICAgIH0sIHRoaXMpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgICAgfVxuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgIHJldHVybiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYiwgb3B0aW9ucykge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gb3B0aW9ucy5oZWFkZXJzLm1hcFsnY29udGVudC10eXBlJ10gPyBvcHRpb25zLmhlYWRlcnMubWFwWydjb250ZW50LXR5cGUnXS50b1N0cmluZygpIDogJydcbiAgICB2YXIgcmVnZXggPSAvY2hhcnNldFxcPVswLTlhLXpBLVpcXC1cXF9dKjs/L1xuICAgIHZhciBfY2hhcnNldCA9IGJsb2IudHlwZS5tYXRjaChyZWdleCkgfHwgY29udGVudFR5cGUubWF0Y2gocmVnZXgpXG4gICAgdmFyIGFyZ3MgPSBbYmxvYl1cblxuICAgIGlmKF9jaGFyc2V0KSB7XG4gICAgICBhcmdzLnB1c2goX2NoYXJzZXRbMF0ucmVwbGFjZSgvXmNoYXJzZXRcXD0vLCAnJykucmVwbGFjZSgvOyQvLCAnJykpXG4gICAgfVxuXG4gICAgcmVhZGVyLnJlYWRBc1RleHQuYXBwbHkocmVhZGVyLCBhcmdzKVxuICAgIHJldHVybiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIC8vIE9ubHkgc3VwcG9ydCBBcnJheUJ1ZmZlcnMgZm9yIFBPU1QgbWV0aG9kLlxuICAgICAgICAvLyBSZWNlaXZpbmcgQXJyYXlCdWZmZXJzIGhhcHBlbnMgdmlhIEJsb2JzLCBpbnN0ZWFkLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IsIHRoaXMuX29wdGlvbnMpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIHJldHVybiByZWplY3RlZCA/IHJlamVjdGVkIDogUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuICAgIGlmIChSZXF1ZXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGlucHV0KSkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IGlucHV0XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnb21pdCdcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSwgb3B0aW9ucylcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhlYWRlcnMoeGhyKSB7XG4gICAgdmFyIGhlYWQgPSBuZXcgSGVhZGVycygpXG4gICAgdmFyIHBhaXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnRyaW0oKS5zcGxpdCgnXFxuJylcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgdmFyIHNwbGl0ID0gaGVhZGVyLnRyaW0oKS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gc3BsaXQuc2hpZnQoKS50cmltKClcbiAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJzonKS50cmltKClcbiAgICAgIGhlYWQuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICByZXR1cm4gaGVhZFxuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCwgb3B0aW9ucylcbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dFxuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgPyBvcHRpb25zLmhlYWRlcnMgOiBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0XG4gICAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgJiYgIWluaXQpIHtcbiAgICAgICAgcmVxdWVzdCA9IGlucHV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICBmdW5jdGlvbiByZXNwb25zZVVSTCgpIHtcbiAgICAgICAgaWYgKCdyZXNwb25zZVVSTCcgaW4geGhyKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVVSTFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgc2VjdXJpdHkgd2FybmluZ3Mgb24gZ2V0UmVzcG9uc2VIZWFkZXIgd2hlbiBub3QgYWxsb3dlZCBieSBDT1JTXG4gICAgICAgIGlmICgvXlgtUmVxdWVzdC1VUkw6L20udGVzdCh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfX29uTG9hZEhhbmRsZWQgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gb25sb2FkKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMpID8gMjA0IDogeGhyLnN0YXR1c1xuICAgICAgICBpZiAoc3RhdHVzIDwgMTAwIHx8IHN0YXR1cyA+IDU5OSkge1xuICAgICAgICAgIGlmIChfX29uTG9hZEhhbmRsZWQpIHsgcmV0dXJuOyB9IGVsc2UgeyBfX29uTG9hZEhhbmRsZWQgPSB0cnVlOyB9XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzKHhociksXG4gICAgICAgICAgdXJsOiByZXNwb25zZVVSTCgpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG5cbiAgICAgICAgaWYgKF9fb25Mb2FkSGFuZGxlZCkgeyByZXR1cm47IH0gZWxzZSB7IF9fb25Mb2FkSGFuZGxlZCA9IHRydWU7IH1cbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gb25sb2FkO1xuICAgICAgeGhyLm9ubG9hZCA9IG9ubG9hZDtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfX29uTG9hZEhhbmRsZWQpIHsgcmV0dXJuOyB9IGVsc2UgeyBfX29uTG9hZEhhbmRsZWQgPSB0cnVlOyB9XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgLy8gYHdpdGhDcmVkZW50aWFsc2Agc2hvdWxkIGJlIHNldHRlZCBhZnRlciBjYWxsaW5nIGAub3BlbmAgaW4gSUUxMFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTk2Njc5NTkvMTIxOTM0M1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlICYmIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLndhcm4oJ3dpdGhDcmVkZW50aWFscyBpcyBub3Qgc3VwcG9ydGVkLCB5b3UgY2FuIGlnbm9yZSB0aGlzIHdhcm5pbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgY29uc29sZS53YXJuKCdzZXQgd2l0aENyZWRlbnRpYWxzIGVycm9yOicgKyBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxuXG4gIC8vIFN1cHBvcnQgQ29tbW9uSlNcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmLmZldGNoO1xuICB9XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fetch-ie8/fetch.js\n")}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var C=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g].call(C.exports,C,C.exports,__webpack_require__),C.exports}__webpack_require__.amdO={},__webpack_require__.n=g=>{var I=g&&g.__esModule?()=>g.default:()=>g;return __webpack_require__.d(I,{a:I}),I},__webpack_require__.d=(g,I)=>{for(var C in I)__webpack_require__.o(I,C)&&!__webpack_require__.o(g,C)&&Object.defineProperty(g,C,{enumerable:!0,get:I[C]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(g){if("object"==typeof window)return window}}(),__webpack_require__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),__webpack_require__.r=g=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./source-src/js/slider.js")})();